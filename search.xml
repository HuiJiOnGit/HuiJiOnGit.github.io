<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>探究下abp的启动和模块系统</title>
      <link href="2022/09/16/study-notes-abp-2022-09-16-tan-jiu-xia-abp-de-qi-dong-he-mo-kuai-xi-tong/"/>
      <url>2022/09/16/study-notes-abp-2022-09-16-tan-jiu-xia-abp-de-qi-dong-he-mo-kuai-xi-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="探究下abp的启动和模块系统"><a href="#探究下abp的启动和模块系统" class="headerlink" title="探究下abp的启动和模块系统"></a>探究下abp的启动和模块系统</h2><p>当你创建一个新的abp应用,你会发现,它的<code>Startup</code>文件特别简洁,如下所示:</p><pre class=" language-c#"><code class="language-c#">public void ConfigureServices(IServiceCollection services)&#123;    services.AddApplication<BookStoreWebModule>();&#125;public void Configure(IApplicationBuilder app)&#123;    app.InitializeApplication();&#125;</code></pre><p>这是怎么做到的? 现在让我一探究竟</p><blockquote><p>它分两步做，相互独立的，它抽象相应的接口，<br>1、将模块的列表遍历注册服务到容器，分三个阶段PreConfigureServices（预注册）、ConfigureServices（注册）、PostConfigureServices（注册后）。<br>2，应用的初始化，即将设置服务提供方ServiceProvider,并执行四个生命周期函数，OnPreApplicationInitialization，OnApplicationInitialization、OnPostApplicationInitialization、OnApplicationShutdown</p></blockquote><h3 id="ConfigureServices的AddApplication"><a href="#ConfigureServices的AddApplication" class="headerlink" title="ConfigureServices的AddApplication"></a><code>ConfigureServices</code>的<code>AddApplication</code></h3><p>首先看看<code>AddApplication&lt;BookStoreWebModule&gt;()</code>这个方法,通过对源码的查找, 这实际是一个扩展方法</p><pre class=" language-c#"><code class="language-c#">public static IAbpApplicationWithExternalServiceProvider AddApplication<TStartupModule>(    [NotNull] this IServiceCollection services,    [CanBeNull] Action<AbpApplicationCreationOptions> optionsAction = null)    where TStartupModule : IAbpModule&#123;    return AbpApplicationFactory.Create<TStartupModule>(services, optionsAction);&#125;</code></pre><p>这里实际是通过<code>AbpApplicationFactory</code>工厂创建了一个<code>IAbpApplicationWithExternalServiceProvider</code>实例</p><p>这个实例名字非常长,最重要的看后面那段<code>External ServiceProvider</code>,翻译过老就是外部应用提供的意思, 什么叫外部应用提供? 就是abp把应用这样区分,是abp内部启动依赖的应用服务就是内部应用, 而用户自己创建的服务就是外部应用了(这是我的理解)</p><p>再来看<code>IAbpApplicationWithExternalServiceProvider</code>的实现类是<code>AbpApplicationWithExternalServiceProvider</code> , 它继承了<code>AbpApplicationBase</code>, <code>IAbpApplicationWithExternalServiceProvider</code>,<br>abp启动的秘密都写在了这个base类中, 看看这里的构造函数</p><pre class=" language-c#"><code class="language-c#">[NotNull]public Type StartupModuleType &#123; get; &#125;public IServiceProvider ServiceProvider &#123; get; private set; &#125;public IServiceCollection Services &#123; get; &#125;public IReadOnlyList<IAbpModuleDescriptor> Modules &#123; get; &#125;public string ApplicationName &#123; get; &#125;private bool _configuredServices;internal AbpApplicationBase(    [NotNull] Type startupModuleType,    [NotNull] IServiceCollection services,    [CanBeNull] Action<AbpApplicationCreationOptions> optionsAction)&#123;    // 1. 检查非空    Check.NotNull(startupModuleType, nameof(startupModuleType));    Check.NotNull(services, nameof(services));    // 2. 把开始的module类型赋值    StartupModuleType = startupModuleType;    Services = services;    services.TryAddObjectAccessor<IServiceProvider>();    var options = new AbpApplicationCreationOptions(services);    optionsAction?.Invoke(options);    ApplicationName = options.ApplicationName;    // 这里把自己注册为这几种类型了    services.AddSingleton<IAbpApplication>(this);    services.AddSingleton<IApplicationNameAccessor>(this);    services.AddSingleton<IModuleContainer>(this);    // 这个是添加了AddOptions AddLogging AddLocalization    services.AddCoreServices();    // 这个方法干了很多事情, 下面详细看看    services.AddCoreAbpServices(this, options);    // 这里就是把个个继承了AbpModule的class都加载好了,并且是经过拓扑排序的    Modules = LoadModules(services, options);    // 这里就是执行AbpModule的ConfigureServices方法的地方了,这个判断是为了避免重复执行的    if (!options.SkipConfigureServices)    &#123;        ConfigureServices();    &#125;&#125;</code></pre><p>下面来看看<code>AddCoreAbpServices</code>方法</p><pre class=" language-c#"><code class="language-c#">internal static void AddCoreAbpServices(this IServiceCollection services,    IAbpApplication abpApplication,    AbpApplicationCreationOptions applicationCreationOptions)&#123;    // 这几个都是用来加载AbpModule用的    var moduleLoader = new ModuleLoader();    var assemblyFinder = new AssemblyFinder(abpApplication);    var typeFinder = new TypeFinder(assemblyFinder);    if (!services.IsAdded<IConfiguration>())    &#123;        services.ReplaceConfiguration(            ConfigurationHelper.BuildConfiguration(                applicationCreationOptions.Configuration            )        );    &#125;    services.TryAddSingleton<IModuleLoader>(moduleLoader);    services.TryAddSingleton<IAssemblyFinder>(assemblyFinder);    services.TryAddSingleton<ITypeFinder>(typeFinder);    services.TryAddSingleton<IInitLoggerFactory>(new DefaultInitLoggerFactory());    services.AddAssemblyOf<IAbpApplication>();    services.AddTransient(typeof(ISimpleStateCheckerManager<>), typeof(SimpleStateCheckerManager<>));    //这里实际是把继承了OnPreApplicationInitialization,OnApplicationInitialization,OnPostApplicationInitialization,OnApplicationShutdown 的几个实现类型加入到AbpModuleLifecycleOptions中的集合中了,后面会用到    services.Configure<AbpModuleLifecycleOptions>(options =>    &#123;        options.Contributors.Add<OnPreApplicationInitializationModuleLifecycleContributor>();        options.Contributors.Add<OnApplicationInitializationModuleLifecycleContributor>();        options.Contributors.Add<OnPostApplicationInitializationModuleLifecycleContributor>();        options.Contributors.Add<OnApplicationShutdownModuleLifecycleContributor>();    &#125;);&#125;</code></pre><p>然后讲下<code>LoadModules</code>这里干了啥,这里调用了<code>IModuleLoader</code>这个服务的<code>LoadModules</code>方法,可以看到,上面已经注册了<code>ModuleLoader</code>这个实现类,这里的代码有点多,但其实干的事情就是把继承了AbpModule的class实例化,然后设置每个Module的依赖, 在每个模块中我们都是使用了那个<code>DependsOn</code>特性来加载需要用到的类型,这其中涉及到了类的依赖,这里就是依次把类型加载,详细看注释</p><pre class=" language-c#"><code class="language-c#">public class ModuleLoader : IModuleLoader&#123;    public IAbpModuleDescriptor[] LoadModules(        IServiceCollection services,        Type startupModuleType,        PlugInSourceList plugInSources)    &#123;        Check.NotNull(services, nameof(services));        Check.NotNull(startupModuleType, nameof(startupModuleType));        Check.NotNull(plugInSources, nameof(plugInSources));        // 获取类型描述        var modules = GetDescriptors(services, startupModuleType, plugInSources);        // 然后给每个Module设置它的依赖, 例如说a依赖b,c,那么这里就是把b,c添加到a的Descriptor的Dependency集合中        modules = SortByDependency(modules, startupModuleType);        return modules.ToArray();    &#125;    private List<IAbpModuleDescriptor> GetDescriptors(        IServiceCollection services,        Type startupModuleType,        PlugInSourceList plugInSources)    &#123;        var modules = new List<AbpModuleDescriptor>();        FillModules(modules, services, startupModuleType, plugInSources);        SetDependencies(modules);        return modules.Cast<IAbpModuleDescriptor>().ToList();    &#125;    protected virtual void FillModules(        List<AbpModuleDescriptor> modules,        IServiceCollection services,        Type startupModuleType,        PlugInSourceList plugInSources)    &#123;        var logger = services.GetInitLogger<AbpApplicationBase>();        /*            AbpModuleHelper.FindAllModuleTypes这里是使用了拓扑排序,从开始类型开始,一路查找其依赖,递归获取依赖的依赖,可以说就是把所有的AbpModule都获取到了        */        //All modules starting from the startup module        foreach (var moduleType in AbpModuleHelper.FindAllModuleTypes(startupModuleType, logger))        &#123;            modules.Add(CreateModuleDescriptor(services, moduleType));        &#125;        //Plugin modules        foreach (var moduleType in plugInSources.GetAllModules(logger))        &#123;            if (modules.Any(m => m.Type == moduleType))            &#123;                continue;            &#125;            modules.Add(CreateModuleDescriptor(services, moduleType, isLoadedAsPlugIn: true));        &#125;    &#125;    protected virtual void SetDependencies(List<AbpModuleDescriptor> modules)    &#123;        foreach (var module in modules)        &#123;            SetDependencies(modules, module);        &#125;    &#125;    protected virtual List<IAbpModuleDescriptor> SortByDependency(List<IAbpModuleDescriptor> modules, Type startupModuleType)    &#123;        var sortedModules = modules.SortByDependencies(m => m.Dependencies);        sortedModules.MoveItem(m => m.Type == startupModuleType, modules.Count - 1);        return sortedModules;    &#125;    protected virtual AbpModuleDescriptor CreateModuleDescriptor(IServiceCollection services, Type moduleType, bool isLoadedAsPlugIn = false)    &#123;        return new AbpModuleDescriptor(moduleType, CreateAndRegisterModule(services, moduleType), isLoadedAsPlugIn);    &#125;    protected virtual IAbpModule CreateAndRegisterModule(IServiceCollection services, Type moduleType)    &#123;        // 这里new了,使用了Activator.CreateInstance来创建的        var module = (IAbpModule)Activator.CreateInstance(moduleType);        services.AddSingleton(moduleType, module);        return module;    &#125;    protected virtual void SetDependencies(List<AbpModuleDescriptor> modules, AbpModuleDescriptor module)    &#123;        foreach (var dependedModuleType in AbpModuleHelper.FindDependedModuleTypes(module.Type))        &#123;            var dependedModule = modules.FirstOrDefault(m => m.Type == dependedModuleType);            if (dependedModule == null)            &#123;                throw new AbpException("Could not find a depended module " + dependedModuleType.AssemblyQualifiedName + " for " + module.Type.AssemblyQualifiedName);            &#125;            module.AddDependency(dependedModule);        &#125;    &#125;&#125;</code></pre><p>之后<code>Module</code>都加载好了,就回到了<code>AbpApplicationBase</code>的构造函数,继续调用<code>ConfigureServices</code>方法了, 这里很好理解,就是按顺序执行<code>PreConfigureServices</code>,<code>ConfigureServices</code>,<code>PostConfigureServices</code>3个方法</p><pre class=" language-c#"><code class="language-c#">public virtual void ConfigureServices()&#123;    CheckMultipleConfigureServices();    var context = new ServiceConfigurationContext(Services);    Services.AddSingleton(context);    foreach (var module in Modules)    &#123;        if (module.Instance is AbpModule abpModule)        &#123;            abpModule.ServiceConfigurationContext = context;        &#125;    &#125;    //PreConfigureServices    foreach (var module in Modules.Where(m => m.Instance is IPreConfigureServices))    &#123;        try        &#123;            ((IPreConfigureServices)module.Instance).PreConfigureServices(context);        &#125;        catch (Exception ex)        &#123;            throw new AbpInitializationException($"An error occurred during &#123;nameof(IPreConfigureServices.PreConfigureServices)&#125; phase of the module &#123;module.Type.AssemblyQualifiedName&#125;. See the inner exception for details.", ex);        &#125;    &#125;    var assemblies = new HashSet<Assembly>();    //ConfigureServices    foreach (var module in Modules)    &#123;        if (module.Instance is AbpModule abpModule)        &#123;            if (!abpModule.SkipAutoServiceRegistration)            &#123;                var assembly = module.Type.Assembly;                if (!assemblies.Contains(assembly))                &#123;                    Services.AddAssembly(assembly);                    assemblies.Add(assembly);                &#125;            &#125;        &#125;        try        &#123;            module.Instance.ConfigureServices(context);        &#125;        catch (Exception ex)        &#123;            throw new AbpInitializationException($"An error occurred during &#123;nameof(IAbpModule.ConfigureServices)&#125; phase of the module &#123;module.Type.AssemblyQualifiedName&#125;. See the inner exception for details.", ex);        &#125;    &#125;    //PostConfigureServices    foreach (var module in Modules.Where(m => m.Instance is IPostConfigureServices))    &#123;        try        &#123;            ((IPostConfigureServices)module.Instance).PostConfigureServices(context);        &#125;        catch (Exception ex)        &#123;            throw new AbpInitializationException($"An error occurred during &#123;nameof(IPostConfigureServices.PostConfigureServices)&#125; phase of the module &#123;module.Type.AssemblyQualifiedName&#125;. See the inner exception for details.", ex);        &#125;    &#125;    foreach (var module in Modules)    &#123;        if (module.Instance is AbpModule abpModule)        &#123;            abpModule.ServiceConfigurationContext = null;        &#125;    &#125;    _configuredServices = true;&#125;</code></pre><p>其中执行<code>ConfigureServices</code>的时候我特别提一下,abp是如何知道,你这个服务的暴露类型的呢?<br>可以看到,注入使用了这个方法<code>Services.AddAssembly</code>,一路f12,发现最后实际执行在<code>DefaultConventionalRegistrar</code>这个类中的<code>AddType</code>方法</p><pre class=" language-c#"><code class="language-c#">public override void AddType(IServiceCollection services, Type type)&#123;    if (IsConventionalRegistrationDisabled(type))    &#123;        return;    &#125;    var dependencyAttribute = GetDependencyAttributeOrNull(type);    // 获取生命周期 ITransientDependency ISingletonDependency IScopedDependency    var lifeTime = GetLifeTimeOrNull(type, dependencyAttribute);    if (lifeTime == null)    &#123;        return;    &#125;    /*        这个方法特地提一下,是获取暴露特性的private static readonly ExposeServicesAttribute DefaultExposeServicesAttribute =new ExposeServicesAttribute&#123;    IncludeDefaults = true,    IncludeSelf = true&#125;;public static List<Type> GetExposedServices(Type type)&#123;    return type        .GetCustomAttributes(true)        .OfType<IExposedServiceTypesProvider>()        .DefaultIfEmpty(DefaultExposeServicesAttribute)        .SelectMany(p => p.GetExposedServiceTypes(type))        .Distinct()        .ToList();&#125;这里充分地使用了linq,可能看有点懵,它的意思是,获取类型中IExposedServiceTypesProvider特性,DefaultIfEmpty是如果没找到这个给特性,那就用这个默认的特性DefaultExposeServicesAttribute,GetExposedServiceTypes是获取这个类型上的接口,IncludeSelf的话,也会把自己获取到,假如 接口b继承接口a, class c 继承了 接口b,那么这里会获取到 [a,b,c]这么一个集合    */    var exposedServiceTypes = GetExposedServiceTypes(type);    // 这里我也不太理解    TriggerServiceExposing(services, type, exposedServiceTypes);    //从这里可以看到,abp是把对应的暴露类型全都一口气注入了,可能有些类型不是你想暴露的,最好还是使用ExposeServicesAttribute标记要暴露的类型    foreach (var exposedServiceType in exposedServiceTypes)    &#123;        var serviceDescriptor = CreateServiceDescriptor(            type,            exposedServiceType,            exposedServiceTypes,            lifeTime.Value        );        if (dependencyAttribute?.ReplaceServices == true)        &#123;            services.Replace(serviceDescriptor);        &#125;        else if (dependencyAttribute?.TryRegister == true)        &#123;            services.TryAdd(serviceDescriptor);        &#125;        else        &#123;            services.Add(serviceDescriptor);        &#125;    &#125;&#125;</code></pre><h3 id="Configure中的InitializeApplication"><a href="#Configure中的InitializeApplication" class="headerlink" title="Configure中的InitializeApplication"></a><code>Configure</code>中的<code>InitializeApplication</code></h3><p>好,<code>AddApplication</code>方法的调用我们就差不多了,接下来看看<code>app.InitializeApplication</code>方法</p><pre class=" language-c#"><code class="language-c#">public static void InitializeApplication([NotNull] this IApplicationBuilder app)&#123;    Check.NotNull(app, nameof(app));    // 还记得base的构造函数注册了个空的,现在就赋值了    app.ApplicationServices.GetRequiredService<ObjectAccessor<IApplicationBuilder>>().Value = app;    // 这个就是一开始提到的    var application = app.ApplicationServices.GetRequiredService<IAbpApplicationWithExternalServiceProvider>();    // asp.net core 自带的生命周期    var applicationLifetime = app.ApplicationServices.GetRequiredService<IHostApplicationLifetime>();    //注册Shutdown事情    applicationLifetime.ApplicationStopping.Register(() =>    &#123;        application.Shutdown();    &#125;);    //注册Dispose事情    applicationLifetime.ApplicationStopped.Register(() =>    &#123;        application.Dispose();    &#125;);    // 初始化就在这里了,这个也是在base类中的    application.Initialize(app.ApplicationServices);    /*        最后会调用base中的        protected virtual void InitializeModules()        &#123;            using (var scope = ServiceProvider.CreateScope())            &#123;                WriteInitLogs(scope.ServiceProvider);                scope.ServiceProvider                    .GetRequiredService<IModuleManager>()                    .InitializeModules(new ApplicationInitializationContext(scope.ServiceProvider));            &#125;        &#125;    */&#125;</code></pre><p>再看看<code>ModuleManager</code>中的<code>InitializeModules</code></p><pre class=" language-c#"><code class="language-c#">public ModuleManager(        IModuleContainer moduleContainer,        ILogger<ModuleManager> logger,        IOptions<AbpModuleLifecycleOptions> options,        IServiceProvider serviceProvider)&#123;    _moduleContainer = moduleContainer;    _logger = logger;    _lifecycleContributors = options.Value        .Contributors        .Select(serviceProvider.GetRequiredService)        .Cast<IModuleLifecycleContributor>()        .ToArray();&#125;public void InitializeModules(ApplicationInitializationContext context)&#123;    //AddCoreAbpServices方法中添加了继承了几个接口的类,就在这里用上了    foreach (var contributor in _lifecycleContributors)    &#123;        //_moduleContainer就是base类        foreach (var module in _moduleContainer.Modules)        &#123;            try            &#123;                contributor.Initialize(context, module.Instance);            &#125;            catch (Exception ex)            &#123;                throw new AbpInitializationException($"An error occurred during the initialize &#123;contributor.GetType().FullName&#125; phase of the module &#123;module.Type.AssemblyQualifiedName&#125;: &#123;ex.Message&#125;. See the inner exception for details.", ex);            &#125;        &#125;    &#125;    _logger.LogInformation("Initialized all ABP modules.");&#125;// 这里在看一个OnApplicationInitialization的实现类OnApplicationInitializationModuleLifecycleContributorpublic class OnApplicationInitializationModuleLifecycleContributor : ModuleLifecycleContributorBase&#123;    public async override Task InitializeAsync(ApplicationInitializationContext context, IAbpModule module)    &#123;        if (module is IOnApplicationInitialization onApplicationInitialization)        &#123;            await onApplicationInitialization.OnApplicationInitializationAsync(context);        &#125;    &#125;    public override void Initialize(ApplicationInitializationContext context, IAbpModule module)    &#123;        (module as IOnApplicationInitialization)?.OnApplicationInitialization(context);    &#125;&#125;</code></pre><p>也就是说, <code>OnPreApplicationInitialization</code>，<code>OnApplicationInitialization</code>、<code>OnPostApplicationInitialization</code>、<code>OnApplicationShutdown</code> 这几个接口的方法就在此时调用</p><p>传统的<code>Configure</code>中的其实就鞋在了<code>OnApplicationInitialization</code>中了, 而且应该只写在startmodule中</p><p>至此,整体的启动流程大致分析完了</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所有的Modlue都是在<code>ConfigureServices</code>中注入,执行<code>PreConfigureServices</code>,<code>ConfigureServices</code>,<code>PostConfigureServices</code>这几个方法的<br>然后在<code>Configure</code>中执行剩下的几个方法,大体就是这样</p>]]></content>
      
      
      <categories>
          
          <category> abp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> abp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>asp.net core 应用部署在Nginx 子目录的探索</title>
      <link href="2022/08/27/study-notes-dotnetcore-2022-08-27-asp-net-core-ying-yong-bu-shu-zai-nginx-zi-mu-lu-de-tan-suo/"/>
      <url>2022/08/27/study-notes-dotnetcore-2022-08-27-asp-net-core-ying-yong-bu-shu-zai-nginx-zi-mu-lu-de-tan-suo/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>由于没有测试用的域名, 一个项目部署到了已有域名的子目录下, 用的<code>Nginx</code>反向代理, 访问链接是这样</p><blockquote><p><code>http://test.com/app</code></p></blockquote><p>然后导致的问题就是页面能访问到了,但是像 js 和 css 的引入全部都 404 了,因为这些文件都是这样引入的</p><blockquote><p><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;~/lib/bootstrap/dist/css/bootstrap.min.css&quot; /&gt;</code></p></blockquote><p>假设现在的域名是<code>test.com</code>,那么现在文件的请求都是</p><blockquote><p><code>http://test.com/lib/bootstrap/dist/css/bootstrap.min.css</code></p></blockquote><p>直接全部 404 了,领导解决这个问题的方式很麻烦,他将所有的这些引用全部修改为了</p><blockquote><p><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;@Model.Host/lib/bootstrap/dist/css/bootstrap.min.css&quot; /&gt;</code></p></blockquote><p>这个<code>Host</code>就是保存在配置的要使用的路径<code>http://test.com/lib</code></p><p>高情商: 这是一个很直接了当的修改方案,大幅提高工作量</p><p>低情商: Rubbish</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>先展示下最开始的<code>nginx</code>的配置</p><pre class=" language-nginx"><code class="language-nginx"><span class="token keyword">server</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>  <span class="token keyword">listen</span> <span class="token number">53346</span><span class="token punctuation">;</span>  <span class="token keyword">server_name</span> localhost<span class="token punctuation">;</span>   <span class="token keyword">location</span> <span class="token operator">/</span>app<span class="token operator">/</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    <span class="token keyword">proxy_pass</span>  <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token punctuation">:</span><span class="token number">5243</span><span class="token operator">/</span><span class="token punctuation">;</span>    <span class="token keyword">proxy_http_version</span> <span class="token number">1.1</span><span class="token punctuation">;</span>    <span class="token keyword">proxy_set_header</span> Upgrade <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>    <span class="token keyword">proxy_set_header</span> Connection keep<span class="token operator">-</span>alive<span class="token punctuation">;</span>    <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span><span class="token punctuation">:</span><span class="token variable">$server_port</span><span class="token punctuation">;</span>    <span class="token keyword">proxy_cache_bypass</span> <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>    <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Forwarded<span class="token operator">-</span>For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>    <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Forwarded<span class="token operator">-</span>Proto <span class="token variable">$scheme</span><span class="token punctuation">;</span>            <span class="token keyword">index</span>  <span class="token keyword">index</span><span class="token punctuation">.</span>html <span class="token keyword">index</span><span class="token punctuation">.</span>htm<span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>        <span class="token keyword">location</span> <span class="token operator">=</span> <span class="token operator">/</span>50x<span class="token punctuation">.</span>html <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>            <span class="token keyword">root</span>   html<span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span></code></pre><h3 id="第一个问题"><a href="#第一个问题" class="headerlink" title="第一个问题"></a>第一个问题</h3><p>加上子目录之后的路径访问会 404, 为什么呢? 很简单,因为加上子目录之后, 路由对不上呢, 比如你要访问 <code>/Home/Index</code>,但是实际访问却是<code>/app/Home/Index</code>,这样改是找不到路由的</p><blockquote><p>搜索一下之后发现, <code>asp.net core</code> 中的<code>PathBase</code>就是设计出来应对这种情况的,就是告诉应用, 我这个请求前面是有一段不算在路由里面的, 你找路由要先排除这个.在中间件开始的地方加上</p></blockquote><pre class=" language-c#"><code class="language-c#">app.UsePathBase(new PathString("/app"));</code></pre><h3 id="第二个问题"><a href="#第二个问题" class="headerlink" title="第二个问题"></a>第二个问题</h3><p>但是访问之后发现, 路由时找到了,但是 js 和 css 都是 404,看控制台发现,这里的请求并没有带上<code>/app</code>,而是直接访问了域名,所以还要调整下,在<code>nginx</code>那里要把<code>/app</code>路径传入进去</p><pre class=" language-Nginx"><code class="language-Nginx"># proxy_pass  http://localhost:5243/;proxy_pass  http://localhost:5243/app/;</code></pre><p>重启<code>nginx</code>之后,访问果然正确显示引用的 js 和 css 了,路径已经加上<code>/app</code>了</p><p>最后贴下完整的配置</p><h4 id="nginx-配置"><a href="#nginx-配置" class="headerlink" title="nginx 配置"></a>nginx 配置</h4><pre class=" language-nginx"><code class="language-nginx"> <span class="token keyword">server</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>  <span class="token keyword">listen</span> <span class="token number">53346</span><span class="token punctuation">;</span>  <span class="token keyword">server_name</span> localhost<span class="token punctuation">;</span>   <span class="token keyword">location</span> <span class="token operator">/</span>app<span class="token operator">/</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>   <span class="token keyword">proxy_pass</span>  <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token punctuation">:</span><span class="token number">5243</span><span class="token operator">/</span>app<span class="token operator">/</span><span class="token punctuation">;</span>   <span class="token keyword">proxy_http_version</span> <span class="token number">1.1</span><span class="token punctuation">;</span>   <span class="token keyword">proxy_set_header</span> Upgrade <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>   <span class="token keyword">proxy_set_header</span> Connection keep<span class="token operator">-</span>alive<span class="token punctuation">;</span>   <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span><span class="token punctuation">:</span><span class="token variable">$server_port</span><span class="token punctuation">;</span>   <span class="token keyword">proxy_cache_bypass</span> <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>   <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Forwarded<span class="token operator">-</span>For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>   <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Forwarded<span class="token operator">-</span>Proto <span class="token variable">$scheme</span><span class="token punctuation">;</span>            <span class="token keyword">index</span>  <span class="token keyword">index</span><span class="token punctuation">.</span>html <span class="token keyword">index</span><span class="token punctuation">.</span>htm<span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>        <span class="token keyword">location</span> <span class="token operator">=</span> <span class="token operator">/</span>50x<span class="token punctuation">.</span>html <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>            <span class="token keyword">root</span>   html<span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span></code></pre><h4 id="c-部分"><a href="#c-部分" class="headerlink" title="c# 部分"></a>c# 部分</h4><pre class=" language-c#"><code class="language-c#">var builder = WebApplication.CreateBuilder(args);// Add services to the container.builder.Services.AddRazorPages();var app = builder.Build();// Configure the HTTP request pipeline.app.UsePathBase(new PathString("/app"));if (!app.Environment.IsDevelopment())&#123;    app.UseExceptionHandler("/Error");&#125;app.UseStaticFiles();app.UseRouting();app.UseAuthorization();app.MapRazorPages();app.Run();</code></pre><h2 id="要注意的点"><a href="#要注意的点" class="headerlink" title="要注意的点"></a>要注意的点</h2><ul><li>链接</li></ul><p>如果你使用了 <code>asp-action</code> <code>asp-router</code> <code>asp-controller</code> 等<code>TagHelper</code>去生成链接的话, 那就会带上子目录的路径的, 如果你直接写一个 a 标签,那这个在代理之后生成的是不会有子目录,所以涉及这个最好使用<code>tagheler</code>来生成.</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">asp-page</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/Privacy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>使用TagHelper生成的<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--生成是这样的&lt;a href="/app/Privacy">使用TagHelper生成的&lt;/a>--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/Private<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>手动写链接的<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--生成如下&lt;a href="/Private">手动写链接的&lt;/a>--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>~/Private<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>手动写链接的,但是使用了~<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--&lt;a href="/app/Private">手动写链接的,但是使用了~&lt;/a>--></span></code></pre><p>建议使用 1,3,不要用 2</p><ul><li>请求</li></ul><p>那 js 请求的话,也是同样道理的,建议使用<code>axios</code>来发送请求,可以轻松的设置<code>baseURL</code>来配置子目录,</p><p>说到这个,不得不提一嘴同事写的解决子目录<code>ajax</code>请求的方法,直接替换了<code>jQuery</code>的发送请求方法, 保存原本的方法在临时变量中, 然后修改请求的 url, 再用保存在临时变量中的方法去发送真正的请求, 不是说不行, 而是<code>jQuery</code>没有这种对应基础配置,只能用这种迂回的方式, 不太好用, 现在<code>jQuery</code>是真的落后了</p><ul><li>其他资源(音频视频)</li></ul><p>这里有两种引入方式,会生成不一样的结果</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/img/001.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">asp-append-version</span> <span class="token punctuation">/></span></span><span class="token comment" spellcheck="true">&lt;!--&lt;img src="/img/001.jpg?v=LWv2Dubq1qrHEyLduWAtYgtEtCVlddyQv-omxaAMgiI">--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>~/img/001.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">asp-append-version</span> <span class="token punctuation">/></span></span><span class="token comment" spellcheck="true">&lt;!--&lt;img src="/app/img/001.jpg?v=LWv2Dubq1qrHEyLduWAtYgtEtCVlddyQv-omxaAMgiI">--></span></code></pre><p>使用后者可以自动添加子目录,推荐使用后者</p><p>另外探究下源码这里是怎么处理<code>PathBase</code>的,首先看看<code>taghelper</code>是怎么处理的,一路顺着源码走下去发现以下调用</p><p><a href="https://github.com/dotnet/aspnetcore/blob/51ccce6d743dddf995b3661f07b0e1990b68dc7d/src/Mvc/Mvc.TagHelpers/src/AnchorTagHelper.cs"><code>AnchorTagHelper</code></a><br>这里无论使用使用路由,action,还是page都是使用了<code>UrlHelperFactory</code>类型的方法,接下看看这个</p><pre class=" language-c#"><code class="language-c#">public override void Process(TagHelperContext context, TagHelperOutput output)&#123;    // 省略了一部分验证    var routeLink = Route != null;    var actionLink = Controller != null || Action != null;    var pageLink = Page != null || PageHandler != null;    if ((routeLink && actionLink) || (routeLink && pageLink) || (actionLink && pageLink))    &#123;        var message = string.Join(            Environment.NewLine,            Resources.FormatCannotDetermineAttributeFor(Href, "<a>"),            RouteAttributeName,            ControllerAttributeName + ", " + ActionAttributeName,            PageAttributeName + ", " + PageHandlerAttributeName);        throw new InvalidOperationException(message);    &#125;    RouteValueDictionary routeValues = null;    if (_routeValues != null && _routeValues.Count > 0)    &#123;        routeValues = new RouteValueDictionary(_routeValues);    &#125;    if (Area != null)    &#123;        // Unconditionally replace any value from asp-route-area.        if (routeValues == null)        &#123;            routeValues = new RouteValueDictionary();        &#125;        routeValues["area"] = Area;    &#125;    TagBuilder tagBuilder;    if (pageLink)    &#123;        tagBuilder = Generator.GeneratePageLink(            ViewContext,            linkText: string.Empty,            pageName: Page,            pageHandler: PageHandler,            protocol: Protocol,            hostname: Host,            fragment: Fragment,            routeValues: routeValues,            htmlAttributes: null);    &#125;    else if (routeLink)    &#123;        tagBuilder = Generator.GenerateRouteLink(            ViewContext,            linkText: string.Empty,            routeName: Route,            protocol: Protocol,            hostName: Host,            fragment: Fragment,            routeValues: routeValues,            htmlAttributes: null);    &#125;    else    &#123;        tagBuilder = Generator.GenerateActionLink(            ViewContext,            linkText: string.Empty,            actionName: Action,            controllerName: Controller,            protocol: Protocol,            hostname: Host,            fragment: Fragment,            routeValues: routeValues,            htmlAttributes: null);    &#125;    output.MergeAttributes(tagBuilder);&#125;</code></pre><p><a href="https://github.com/dotnet/aspnetcore/tree/2ae595a71b202f2f957f2909e0b6b99dd563c0db/src/Mvc/Mvc.Core/src/Routing/UrlHelperFactory.cs"><code>UrlHelperFactory</code></a><br>然后这里有个分支,有两个实现了<code>IUrlHelper</code>的类型,一个是<code>EndpointRoutingUrlHelper</code>,另外一个是<code>UrlHelper</code>,由于没有调试,只能两个都看看,</p><pre class=" language-c#"><code class="language-c#">public IUrlHelper GetUrlHelper(ActionContext context)&#123;    // 省略了一部分验证    var endpoint = httpContext.GetEndpoint();    if (endpoint != null)    &#123;        var services = httpContext.RequestServices;        var linkGenerator = services.GetRequiredService<LinkGenerator>();        var logger = services.GetRequiredService<ILogger<EndpointRoutingUrlHelper>>();        urlHelper = new EndpointRoutingUrlHelper(            context,            linkGenerator,            logger);    &#125;    else    &#123;        urlHelper = new UrlHelper(context);    &#125;    httpContext.Items[typeof(IUrlHelper)] = urlHelper;    return urlHelper;&#125;</code></pre><p>最后看到其实两个<code>IUrlHelper</code>都是使用了<code>UrlHelperBase</code>父类中的<code>GenerateUrl</code>方法,然后这两个方法都会调用到<code>AppendPathAndFragment</code>这个方法,</p><pre class=" language-c#"><code class="language-c#">internal static void AppendPathAndFragment(StringBuilder builder, PathString pathBase, string virtualPath, string? fragment)&#123;    if (!pathBase.HasValue)    &#123;        if (virtualPath.Length == 0)        &#123;            builder.Append('/');        &#125;        else        &#123;            if (!virtualPath.StartsWith('/'))            &#123;                builder.Append('/');            &#125;            builder.Append(virtualPath);        &#125;    &#125;    else    &#123;        if (virtualPath.Length == 0)        &#123;            builder.Append(pathBase.Value);        &#125;        else        &#123;            builder.Append(pathBase.Value);            if (pathBase.Value.EndsWith("/", StringComparison.Ordinal))            &#123;                builder.Length--;            &#125;            if (!virtualPath.StartsWith("/", StringComparison.Ordinal))            &#123;                builder.Append('/');            &#125;            builder.Append(virtualPath);        &#125;    &#125;    if (!string.IsNullOrEmpty(fragment))    &#123;        builder.Append('#').Append(fragment);    &#125;&#125;</code></pre><p>至此,<code>TagHelper</code>是怎么处理<code>PathBase</code>已完全解开秘密.</p><p>还有个疑问,为什么用<code>~</code>这个符号开始的链接也能正确显示?</p><p>大概猜测是在<code>UrlHelperBase</code>的<code>TryFastGenerateUrl</code>中,还不是很确定</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过<code>nginx</code>的配置就完全可以解决部署在子目录中的问题, 部署的问题就应该交给反向代理方处理而不是硬改代码,代码应尽量少改才对.</p><p>还是就是我上面是测试用,所以子目录在代码中是写死, 实际应用中应该写到配置中可以灵活应用</p><p>另外就是要注意 nginx 中的代理和转发最后都要有<code>/</code>,不然点击链接会出现跳转 404</p><blockquote><p>另外圣杰大佬那篇非常详细,十分值得收藏!</p></blockquote><p>参考:</p><ol><li><p><a href="https://www.cnblogs.com/xwgli/p/12918904.html">使用 nginx 配置子路径访问 asp.net core 网站时，对 view 中路径生成的处理 - 不是豆豆的旮旯</a></p></li><li><p><a href="https://www.cnblogs.com/sheng-jie/p/Deploy-ASP-NET-CORE-WITH-REVERSE-PROXY.html">ASP.NET Core 反向代理部署知多少 - 圣杰</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> aspnetcore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aspnetcore </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非递归实现广度优先遍历和深度优先遍历</title>
      <link href="2022/07/07/study-notes-algorithm-2022-07-07-fei-di-gui-shi-xian-guang-du-you-xian-bian-li-he-shen-du-you-xian-bian-li/"/>
      <url>2022/07/07/study-notes-algorithm-2022-07-07-fei-di-gui-shi-xian-guang-du-you-xian-bian-li-he-shen-du-you-xian-bian-li/</url>
      
        <content type="html"><![CDATA[<p>记录下学习这两个遍历的过程</p><h2 id="什么是广度优先遍历和深度优先遍历"><a href="#什么是广度优先遍历和深度优先遍历" class="headerlink" title="什么是广度优先遍历和深度优先遍历"></a>什么是广度优先遍历和深度优先遍历</h2><p>来源百度百科</p><blockquote><p>BFS，其英文全称是Breadth First Search。 BFS并不使用经验法则算法。从算法的观点，所有因为展开节点而得到的子节点都会被加进一个先进先出的队列中。一般的实验里，其邻居节点尚未被检验过的节点会被放置在一个被称为 open 的容器中（例如队列或是链表），而被检验过的节点则被放置在被称为 closed 的容器中。（open-closed表）.<br>DFS 没找到合适的说明,请自行搜索</p></blockquote><p>先列出代码,其他的以后再补</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * 广度优先搜索 * @param &amp;#123;object&amp;#125; obj 要遍历的对象 * @param &amp;#123;string&amp;#125; filterKey 要筛选的key * @returns &amp;#123;array&amp;#125;  */</span><span class="token keyword">function</span> <span class="token function">breadthFirstSearch</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> filterKey<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//声明节点</span>    <span class="token keyword">const</span> nodes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//判断终止条件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>keys<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//声明一个队列,来存储要处理的节点</span>        <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        keys<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>k <span class="token operator">=</span><span class="token operator">></span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> name<span class="token punctuation">:</span> k<span class="token punctuation">,</span> value<span class="token punctuation">:</span> obj<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//从队列头中取出要处理的节点</span>            <span class="token keyword">const</span> item <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//加入到nodes中</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>filterKey<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                filterKey <span class="token operator">===</span> item<span class="token punctuation">.</span>name <span class="token operator">&amp;&amp;</span> nodes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                nodes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//再处理所有子节点</span>            <span class="token keyword">const</span> childrenKeys <span class="token operator">=</span> <span class="token keyword">typeof</span> item<span class="token punctuation">.</span>value <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">||</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">?</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> childrenKeys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//把子节点添加到队列中</span>                <span class="token keyword">const</span> childKey <span class="token operator">=</span> childrenKeys<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>                queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> name<span class="token punctuation">:</span> childKey<span class="token punctuation">,</span> value<span class="token punctuation">:</span> item<span class="token punctuation">.</span>value<span class="token punctuation">[</span>childKey<span class="token punctuation">]</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> nodes<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 深度优先遍历 * @param &amp;#123;object&amp;#125; obj  * @param &amp;#123;string&amp;#125; filterKey 要筛选的key * @returns  */</span><span class="token keyword">function</span> <span class="token function">depthFirstSearch</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> filterKey<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> nodes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>keys<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用堆栈存储</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> index <span class="token operator">=</span> keys<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> index <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> index<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">const</span> key <span class="token operator">=</span> keys<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>            stack<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> name<span class="token punctuation">:</span> key<span class="token punctuation">,</span> value<span class="token punctuation">:</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">const</span> item <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>filterKey<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                filterKey <span class="token operator">===</span> item<span class="token punctuation">.</span>name <span class="token operator">&amp;&amp;</span> nodes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                nodes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">const</span> childrenKeys <span class="token operator">=</span> <span class="token keyword">typeof</span> item<span class="token punctuation">.</span>value <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">||</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">?</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> index <span class="token operator">=</span> childrenKeys<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> index <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> index<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">const</span> childKey <span class="token operator">=</span> childrenKeys<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>                stack<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> name<span class="token punctuation">:</span> childKey<span class="token punctuation">,</span> value<span class="token punctuation">:</span> item<span class="token punctuation">.</span>value<span class="token punctuation">[</span>childKey<span class="token punctuation">]</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> nodes<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>这里我是用来遍历不知深浅的对象的,所以里面可能跟平时看到的不太一样</p><p>这里我总结下就是</p><ul><li>广度用队列,把每一层的节点按顺序加入到队列中,然后while循环处理</li><li>深度用栈, 把一条路下的节点倒叙压栈, 然后while循环处理, 这样就不用递归</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> dfs </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-7-7 手动封装一个select</title>
      <link href="2022/07/07/study-notes-others-2022-07-07-shou-dong-feng-zhuang-yi-ge-select/"/>
      <url>2022/07/07/study-notes-others-2022-07-07-shou-dong-feng-zhuang-yi-ge-select/</url>
      
        <content type="html"><![CDATA[<h2 id="手动封装一个select"><a href="#手动封装一个select" class="headerlink" title="手动封装一个select"></a>手动封装一个select</h2><blockquote><p>Q: 为什么要手动封装?</p></blockquote><ul><li>用户提出需求是可以根据select中值的不同显示不同的样式, 比如选 true 显示绿色, 选 false 显示红色,一开始我以为能用css自定义的,但是查阅mdn之后发现像select这种高级控件是不支持的</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Forms/Styling_web_forms">为什么使用 CSS 美化表单组件这么困难?</a></p><p>所以我打算手动封装一个, 思路来源于<a href="https://segmentfault.com/a/1190000017327739">“小小蚊子”</a>,非常感谢!</p><p>由于我这里使用vue, 那正好封装成一个vue组件,直接上代码</p><pre class=" language-js"><code class="language-js">Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'c-select'</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    model<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        prop<span class="token punctuation">:</span> <span class="token string">'selectedValue'</span><span class="token punctuation">,</span>        event<span class="token punctuation">:</span> <span class="token string">'change'</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    props<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        placeholder<span class="token punctuation">:</span> String<span class="token punctuation">,</span>        selectedValue<span class="token punctuation">:</span> Boolean<span class="token punctuation">,</span>        optionType<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            type<span class="token punctuation">:</span> Number <span class="token operator">|</span> String<span class="token punctuation">,</span>            <span class="token string">'default'</span><span class="token punctuation">:</span> <span class="token number">1</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        disabled<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            type<span class="token punctuation">:</span> Boolean<span class="token punctuation">,</span>            <span class="token string">'default'</span><span class="token punctuation">:</span> <span class="token boolean">false</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            isDown<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>            options<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> key<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> label<span class="token punctuation">:</span> <span class="token string">'通过'</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">:</span> <span class="token string">'success'</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> key<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> label<span class="token punctuation">:</span> <span class="token string">'失败'</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">:</span> <span class="token string">'fail'</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            options1<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> key<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> label<span class="token punctuation">:</span> <span class="token string">'是'</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">:</span> <span class="token string">'defualt_true'</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> key<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> label<span class="token punctuation">:</span> <span class="token string">'否'</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">:</span> <span class="token string">'defualt_false'</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            selectedLabel<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>            selectedClass<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    methods<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">selectMainClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>disabled<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>isDown <span class="token operator">=</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>isDown<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token function">itemClick</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>isDown <span class="token operator">=</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>isDown<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>selectedLabel <span class="token operator">=</span> item<span class="token punctuation">.</span>label<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>selectedClass <span class="token operator">=</span> item<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'change'</span><span class="token punctuation">,</span> item<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token function">selectValueChange</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> item <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dynamicOptions<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>f <span class="token operator">=</span><span class="token operator">></span> f<span class="token punctuation">.</span>value <span class="token operator">===</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            console<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`[CustomSelect Event] selectedValue is $&amp;#123;value&amp;#125;`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>selectedLabel <span class="token operator">=</span> item<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>label<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>selectedClass <span class="token operator">=</span> item<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    computed<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">dynamicOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>optionType<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'1'</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>options<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>options1<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token function">disabledClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>disabled <span class="token operator">?</span> <span class="token string">'is-disabled'</span> <span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    watch<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">selectedValue</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">selectValueChange</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">selectValueChange</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>selectedValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`&lt;div style="position: relative;">    &lt;div class="c-select" @click="selectMainClick">        &lt;div :class="['c-select__input', selectedClass, disabledClass]">            &lt;span>                &amp;#123;&amp;#123;selectedLabel || placeholder&amp;#125;&amp;#125;                &lt;span class="c-select__input__suffix">                    &lt;i class="fa fa-angle-down" aria-hidden="true">&lt;/i>                &lt;/span>            &lt;/span>        &lt;/div>    &lt;/div>    &lt;ul class="c-select-dropdown__list" :style="&amp;#123;'display': isDown ? 'block': 'none'&amp;#125;">        &lt;li :class="['c-select-dropdown__item', item.class]" v-for="item in dynamicOptions" :key="item.key" @click.prevent.stop="itemClick(item)">&amp;#123;&amp;#123;item.label&amp;#125;&amp;#125;&lt;/li>    &lt;/ul>&lt;/div>`</span></span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>css 部分参考了element-ui的</p><pre class=" language-CSS"><code class="language-CSS">:root &#123;    --success-color: green;    --fail-color: red;    --black-color: black;    --select-bg: rgba(49, 104, 255, 0.67);    --line-height: 34px;&#125;.c-select &#123;    width: 100%;    cursor: pointer;&#125;.c-select__input &#123;    position: relative;    width: 100%;    height: var(--line-height);    line-height: var(--line-height);    border-radius: 4px;    background: #fff;    color: #999;    font-size: larger;    font-weight: bolder;&#125;.c-select__input__suffix &#123;    position: absolute;    height: 100%;    right: 5px;    top: 0;    text-align: center;    color: #555;    transition: all .3s;    pointer-events: none;&#125;.c-select__input__suffix>i &#123;    line-height: var(--line-height);&#125;.c-select .c-select__input.is-disabled &#123;    cursor: not-allowed;&#125;.c-select__input.is-disabled &#123;    cursor: not-allowed;    background-color: #eee;    opacity: 1;&#125;.c-select-dropdown__list &#123;    position: absolute;    display: none;    margin-top: 2px;    width: 100%;    border: 1px solid #ccc;    border-radius: 4px;    background: #fff;    z-index: 30000;&#125;.c-select-dropdown__item &#123;    height: var(--line-height);    line-height: var(--line-height);    font-size: 14px;    color: #666;&#125;.c-select-dropdown__item:hover &#123;    color: #fff;    background: var(--select-bg);&#125;/* 自定义选项样式*//*测试结果:是*/.c-select-dropdown__item.success &#123;    color: var(--success-color);&#125;.c-select__input.success &#123;    color: var(--success-color);&#125;/*测试结果:否*/.c-select__input.fail &#123;    color: var(--fail-color);&#125;.c-select-dropdown__item.fail &#123;    color: var(--fail-color);&#125;/*问题点:是*/.c-select-dropdown__item.defualt_true &#123;    font-size: 14px;    font-weight: initial;    color: var(--fail-color);&#125;.c-select__input.defualt_true &#123;    font-size: 14px;    font-weight: normal;    color: var(--fail-color);&#125;/*问题点:否*/.c-select-dropdown__item.defualt_false &#123;    font-size: 14px;    font-weight: normal;    color: var(--black-color);&#125;.c-select__input.defualt_false &#123;    font-size: 14px;    font-weight: normal;    color: var(--black-color);&#125;</code></pre><p>使用</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>c-select</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>c-select</span><span class="token punctuation">></span></span></code></pre><p>实现的关键点</p><ol><li>使用了v-model绑定, 在组件里面使用model选项修改默认的v-model行为.</li><li>当子元素是绝对定位的时候,宽度是会跟相对定位的父元素保持一致,如果父元素没有相对定位的,那就是body的宽度了,所以你能看到我在根节点加了相对定位</li></ol><p>不过这个东西还不算成熟,还有很多缺陷</p><ul><li>客户的需求没有更复杂,所以就把数据源都写里面了,没有用prop,更好应该使用prop的</li><li>就是这里面有个问题就是点击了弹出下拉选择项之后,你点其他位置,非组件元素,下拉选择是不能主动消失的,和原生组件的行为不一样,这个暂时还没有好想法去实现</li><li>就是下拉生成的位置其实不要在那里,放到body下面可能会更好,不懂为什么,看人家ele是这样干,我想应该有他的道理</li></ul><p>2022-08-26更新,问了下朋友之后采用监听全局的点击来解决第二个问题点</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>script setup<span class="token operator">></span><span class="token keyword">import</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> ref<span class="token punctuation">,</span> onMounted <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">const</span> num <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> msg <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> show <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> popper <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> btnClick <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//点击下拉列表的选项之后就隐藏下拉</span>  show<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token operator">!</span>show<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">const</span> globalClick <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  msg<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">"global know you click"</span><span class="token punctuation">;</span>  num<span class="token punctuation">.</span>value<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//判断点击事件的触发是否在下拉列表中,如果不是,那就隐藏下拉列表</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>e<span class="token punctuation">.</span>path<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> s <span class="token operator">===</span> popper<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    show<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//监听全局的点击事件,注意是捕获阶段,第三个参数根据mdn的推荐是用一个对象来传参,虽然很多旧文章都是直接使用一个true,但是按mdn的来使用比较好</span>  document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> globalClick<span class="token punctuation">,</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    capture<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>h1<span class="token operator">></span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> msg <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>  <span class="token operator">&lt;</span>h4<span class="token operator">></span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> num <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>h4<span class="token operator">></span>  <span class="token operator">&lt;</span>button @click<span class="token punctuation">.</span>stop<span class="token punctuation">.</span>prevent<span class="token operator">=</span><span class="token string">"btnClick"</span><span class="token operator">></span>click me<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>  <span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token string">"popper"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"popper"</span> v<span class="token operator">-</span>show<span class="token operator">=</span><span class="token string">"show"</span><span class="token operator">></span>look at me<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>style scope<span class="token operator">></span><span class="token punctuation">.</span>popper <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  width<span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  height<span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>  background<span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>  border<span class="token punctuation">:</span> 1px solid red<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">></span></code></pre><p>第三点的问题, vue3有个<code>Teleport</code>组件可以做这种传送的,如果要放到body下,使用这个应该会简单点</p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>window powershell install softword</title>
      <link href="2022/06/25/scripts-notes-2022-06-25-window-powershell-install-softword/"/>
      <url>2022/06/25/scripts-notes-2022-06-25-window-powershell-install-softword/</url>
      
        <content type="html"><![CDATA[<h2 id="使用winget来安装应用"><a href="#使用winget来安装应用" class="headerlink" title="使用winget来安装应用"></a>使用winget来安装应用</h2><p>我用的powershell是 7.2.4 ,正好可以在今天升级,搭配 window 终端来使用更佳</p><p>先看看 <code>winget</code>都有什么功能 </p><ul><li><code>winget</code></li></ul><pre class=" language-shell"><code class="language-shell">Windows 程序包管理器 v1.2.10941版权所有 (C) Microsoft Corporation。保留所有权利。WinGet 命令行实用工具可从命令行安装应用程序和其他程序包。使用情况: winget [<命令>] [<选项>]下列命令有效:  install    安装给定的程序包  show       显示包的相关信息  source     管理程序包的来源  search     查找并显示程序包的基本信息  list       显示已安装的程序包  upgrade    升级给定的程序包  uninstall  卸载给定的程序包  hash       哈希安装程序的帮助程序  validate   验证清单文件  settings   打开设置或设置管理员设置  features   显示实验性功能的状态  export     导出已安装程序包的列表  import     安装文件中的所有程序包如需特定命令的更多详细信息，请向其传递帮助参数。 [-?]下列选项可用：  -v,--version  显示工具的版本  --info        显示工具的常规信息可在此找到更多帮助： https://aka.ms/winget-command-help</code></pre><p>提示已经很明白了,好,那么我们先来 搜索下我们要安装的包 <code>powershell</code> ,要小心这里可能也有其他人上传包名一样的,要用id来下载</p><ul><li><code>winget search powershell</code></li></ul><pre class=" language-shell"><code class="language-shell">名称                            ID                                          版本         匹配            源----------------------------------------------------------------------------------------------------------------PowerShell                      9MZ1SNWT0N5D                                Unknown                      msstorePowerShell Preview              9P95ZZKTNRN4                                Unknown                      msstorePowerShell Conference Asia 2015 9WZDNCRD37D8                                Unknown                      msstorePowerShell                      Microsoft.PowerShell                        7.2.5.0                      wingetWindows Terminal Preview        Microsoft.WindowsTerminal.Preview           1.14.1432.0  Tag: PowerShell wingetWindows Terminal                Microsoft.WindowsTerminal                   1.13.11431.0 Tag: powershell wingetPowerShell Preview              Microsoft.PowerShell.Preview                7.3.0.5      Tag: powershell wingetConEmu                          Maximus5.ConEmu                             11.220.4180  Tag: powershell wingetEasyConnect                     lstratman.easyconnect                       3.1.0.105    Tag: powershell wingetOh My Posh                      JanDeDobbeleer.OhMyPosh                     8.6.0        Tag: powershell wingetTfsCmdlets                      Igoravl.TfsCmdlets                          2.4.0.2768   Tag: powershell wingetelecterm                        electerm.electerm                           1.21.88      Tag: powershell wingetwol                             DarkfullDante.wol                           1.0.2        Tag: powershell wingetAutomatedLab                    AutomatedLab.AutomatedLab                   5.42.0       Tag: powershell wingetPowerShell Universal            IronmanSoftware.PowerShellUniversal         2.10.2                       wingetPowerShell Universal Desktop    IronmanSoftware.PowerShellUniversal.Desktop 2.10.2                       winget</code></pre><p>我们要使用 Id是 <code>Microsoft.PowerShell</code> 这个</p><ul><li><code>winget install Microsoft.PowerShell</code></li></ul><p>然后就可以自动下载软件了,省的自己去<code>GitHub</code>下载一次,因为我这里经常抽风,连不上</p>]]></content>
      
      
      
        <tags>
            
            <tag> winget </tag>
            
            <tag> powershell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享一个自动给aspnetcore mvc razorpage应用自动添加version的方案</title>
      <link href="2022/06/25/study-notes-dotnetcore-2022-06-25-fen-xiang-yi-ge-zi-dong-gei-aspnetcore-mvc-razorpage-ying-yong-zi-dong-tian-jia-version-de-fang-an/"/>
      <url>2022/06/25/study-notes-dotnetcore-2022-06-25-fen-xiang-yi-ge-zi-dong-gei-aspnetcore-mvc-razorpage-ying-yong-zi-dong-tian-jia-version-de-fang-an/</url>
      
        <content type="html"><![CDATA[<h2 id="分享一个自动给aspnetcore-mvc-razorpage应用自动添加version的方案"><a href="#分享一个自动给aspnetcore-mvc-razorpage应用自动添加version的方案" class="headerlink" title="分享一个自动给aspnetcore mvc razorpage应用自动添加version的方案"></a>分享一个自动给aspnetcore mvc razorpage应用自动添加version的方案</h2><p>使用<code>taghelper</code></p><p>直接上代码</p><pre class=" language-c#"><code class="language-c#">using System.Text.Encodings.Web;using Microsoft.AspNetCore.Mvc.Razor.TagHelpers;using Microsoft.AspNetCore.Mvc.Routing;using Microsoft.AspNetCore.Mvc.TagHelpers;using Microsoft.AspNetCore.Razor.TagHelpers;using Microsoft.AspNetCore.WebUtilities;namespace TagHelperDemo.TagHelpers;[HtmlTargetElement("script", Attributes = "src")][HtmlTargetElement("script", Attributes = _appendVersionAttributeName)]public class VersionTagHelper : UrlResolutionTagHelper&#123;    private const string SrcAttributeName = "src";    private const string _appendVersionAttributeName = "asp-append-version";    private const string _srcAttributeName = "src";    private const string _versionKey = "v";    private readonly IWebHostEnvironment _environment;    /// <summary>    /// Source of the image.    /// </summary>    /// <remarks>    /// Passed through to the generated HTML in all cases.    /// </remarks>    [HtmlAttributeName(_srcAttributeName)]    public string Src &#123; get; set; &#125;    /// <summary>    /// Value indicating if file version should be appended to the src urls.    /// </summary>    /// <remarks>    /// If <c>true</c> then a query string "v" with the encoded content of the file is added.    /// </remarks>    [HtmlAttributeName(_appendVersionAttributeName)]    public bool? AppendVersion &#123; get; set; &#125;    /// <inheritdoc />    //public override int Order => 1;    public VersionTagHelper(IUrlHelperFactory urlHelperFactory, HtmlEncoder htmlEncoder, IWebHostEnvironment environment) : base(urlHelperFactory, htmlEncoder)    &#123;        _environment = environment;    &#125;    public override void Process(TagHelperContext context, TagHelperOutput output)    &#123;        if (context == null)        &#123;            throw new ArgumentNullException(nameof(context));        &#125;        if (output == null)        &#123;            throw new ArgumentNullException(nameof(output));        &#125;        //添加了添加version的不用管        if (AppendVersion.HasValue && AppendVersion.Value)        &#123;            return;        &#125;        // Pass through attribute that is also a well-known HTML attribute.        if (Src != null)        &#123;            output.CopyHtmlAttribute(SrcAttributeName, context);        &#125;        // If there's no "src" attribute in output.Attributes this will noop.        //这个方法会将 "~/"替换为应用路径        ProcessUrlAttribute(SrcAttributeName, output);        // Retrieve the TagHelperOutput variation of the "src" attribute in case other TagHelpers in the        // pipeline have touched the value. If the value is already encoded this ScriptTagHelper may        // not function properly.        Src = output.Attributes[SrcAttributeName]?.Value as string;        if (Src is null)        &#123;            return;        &#125;        var resolvedPath = Src;        var queryStringOrFragmentStartIndex = Src.AsSpan().IndexOfAny('?', '#');        if (queryStringOrFragmentStartIndex != -1)        &#123;            resolvedPath = Src[..queryStringOrFragmentStartIndex];        &#125;        //判断引用是否是相对地址,相对不要改        if (Uri.TryCreate(resolvedPath, UriKind.Absolute, out var uri) && !uri.IsFile)        &#123;            // Don't append version if the path is absolute.            return;        &#125;        var value = QueryHelpers.AddQueryString(Src, _versionKey, "1.0.0");        output.Attributes.SetAttribute(_srcAttributeName, value);    &#125;    private bool IsDevelopment()    &#123;        return _environment.IsDevelopment();    &#125;&#125;</code></pre><p>一些代码说明</p><ul><li><code>HtmlTargetElement</code>特性是标记要在什么标签上使用,我这里写了<code>script</code> 和 <code>script</code>标签中带有<code>asp-append-version</code> 两种情况的,你也可以给 <code>link</code> 标签加上,这里我不需要就不加了.</li><li>此类型不需要注入</li><li>还要记得在 <code>_ViewImports.cshtml</code> 文件中引入程序集<blockquote><p><code>@addTagHelper *, TagHelperDemo</code></p></blockquote></li><li>可以在构建函数中注入你已经注入服务,所以,是可以从appsetting文件中获取当前版本号来写入</li><li>由于<code>aspnetcore</code>自带一个<code>asp-append-version</code>的功能,为了不冲突,我这里是二选一的,其实本质我也是推荐用自带的,而不是用上面那个,不过公司业务需要,可以从这里参考</li></ul>]]></content>
      
      
      <categories>
          
          <category> aspnetcore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aspnetcore </tag>
            
            <tag> taghelp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3 学习笔记 01</title>
      <link href="2022/03/24/study-notes-vue3-2022-3-24-01/"/>
      <url>2022/03/24/study-notes-vue3-2022-3-24-01/</url>
      
        <content type="html"><![CDATA[<p>这是有关 vue3 的学习笔记,记录下内容<br>另外推荐使用这个网站 <a href="https://sfc.vuejs.org/"><code>Vue SFC Playground</code></a> 进行 SFC 的测试,不用在本地安装任何东西<br>还有<a href="https://v3.cn.vuejs.org/">官方文档</a></p><h2 id="vue-的编译时运行时"><a href="#vue-的编译时运行时" class="headerlink" title="vue 的编译时运行时"></a>vue 的编译时运行时</h2><p>之前没有太过了解这个,这次看文档学习到, vue 是区分运行时和编译时的,编译时就是需要在客户端上编译模板,运行时是直接运行编译好的模板</p><blockquote><p><a href="https://v3.cn.vuejs.org/guide/installation.html#%E8%BF%90%E8%A1%8C%E6%97%B6-%E7%BC%96%E8%AF%91%E5%99%A8-vs-%E4%BB%85%E8%BF%90%E8%A1%8C%E6%97%B6">请看这里</a></p></blockquote><h2 id="vue-不同构建版本的解释"><a href="#vue-不同构建版本的解释" class="headerlink" title="vue 不同构建版本的解释"></a>vue 不同构建版本的解释</h2><blockquote><p>Vue3 中不再构建 UMD 模块化的方式，因为 UMD 会让代码有更多的冗余，它要支持多种模块化的方式。Vue3 中将 CJS、ESModule 和自执行函数的方式分别打包到了不同的文件中。在 packages/vue 中有 Vue3 的不同构建版本。</p></blockquote><h3 id="使用-CDN-或没有构建工具"><a href="#使用-CDN-或没有构建工具" class="headerlink" title="使用 CDN 或没有构建工具"></a>使用 CDN 或没有构建工具</h3><p><code>vue(.runtime).global(.prod).js</code></p><ul><li><code>.runtime</code>是指至包含运行时</li><li><code>.global</code> 是包含了编译器和运行时的完整构建版本</li><li><code>.prod</code> 包含硬编码的 prod/dev 分支，并且 prod 构建版本是预先压缩过的。将 *.prod.js 文件用于生产环境。</li></ul><p><code>vue(.runtime).esm-browser(.prod).js</code></p><ul><li>用于通过原生 ES 模块导入使用 (在浏览器中通过 <code>&lt;script type=&quot;module&quot;&gt;</code> 来使用)。</li><li>与全局构建版本共享相同的运行时编译、依赖内联和硬编码的 prod/dev 行为。</li></ul><h3 id="使用构建工具"><a href="#使用构建工具" class="headerlink" title="使用构建工具"></a>使用构建工具</h3><p><code>vue(.runtime).esm-bundler.js</code></p><h3 id="服务端渲染-SSR"><a href="#服务端渲染-SSR" class="headerlink" title="服务端渲染 SSR"></a>服务端渲染 SSR</h3><p><code>vue.cjs(.prod).js</code></p><p>参考:</p><p><a href="https://v3.cn.vuejs.org/guide/installation.html#%E4%BD%BF%E7%94%A8-cdn-%E6%88%96%E6%B2%A1%E6%9C%89%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7">官方</a></p><p><a href="https://www.jianshu.com/p/35d0e4b8e0cc">简书一篇博客</a></p><h2 id="创建实例的方式变化"><a href="#创建实例的方式变化" class="headerlink" title="创建实例的方式变化"></a>创建实例的方式变化</h2><ul><li>Vue2</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 选项 */</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>Vue3</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> app <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">createApp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 选项 */</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>3 使用一个方法来创建实例而不是使用 new 的方式<br>可以在这个实例的基础上使用链式继续添加组件和指令</p><pre class=" language-js"><code class="language-js">Vue<span class="token punctuation">.</span><span class="token function">createApp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">"SearchInput"</span><span class="token punctuation">,</span> SearchInputComponent<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">"focus"</span><span class="token punctuation">,</span> FocusDirective<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>LocalePlugin<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="根组件挂载变化"><a href="#根组件挂载变化" class="headerlink" title="根组件挂载变化"></a>根组件挂载变化</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> RootComponent <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 选项 */</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">createApp</span><span class="token punctuation">(</span>RootComponent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> vm <span class="token operator">=</span> app<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">"#app"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用上面方法的实例调用要挂载的 Dom,这个方法是返回了根组件的实例,所以应该写在最后</p><h2 id="在模板中只能使用如下有限的全局变量"><a href="#在模板中只能使用如下有限的全局变量" class="headerlink" title="在模板中只能使用如下有限的全局变量"></a>在模板中只能使用如下有限的全局变量</h2><pre class=" language-ts"><code class="language-ts"><span class="token keyword">import</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> makeMap <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">from</span> <span class="token string">"./makeMap"</span><span class="token punctuation">;</span><span class="token keyword">const</span> GLOBALS_WHITE_LISTED <span class="token operator">=</span>  <span class="token string">"Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,"</span> <span class="token operator">+</span>  <span class="token string">"decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,"</span> <span class="token operator">+</span>  <span class="token string">"Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> isGloballyWhitelisted <span class="token operator">=</span>  <span class="token comment" spellcheck="true">/*#__PURE__*/</span> <span class="token function">makeMap</span><span class="token punctuation">(</span>GLOBALS_WHITE_LISTED<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><a href="https://github.com/vuejs/core/blob/main/packages/shared/src/globalsWhitelist.ts#L3">来源</a></p><p>如果非要用的话,我个人是不推荐的,不过像我身边人那样硬要用,可以先用 extend 或 minx 全局添加进来</p><h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><p>这个不是 vue3 特有,但是看文档过程发现自己掌握不到位,特此记录</p><pre class=" language-js"><code class="language-js">app<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">"save-button"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用 Lodash 实现防抖</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>debouncedClick <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">debounce</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>click<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  <span class="token function">unmounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 移除组件时，取消定时器</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>debouncedClick<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// ... 响应点击 ...</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`    &lt;button @click="debouncedClick">      Save    &lt;/button>  `</span></span><span class="token punctuation">,</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>正确用法是在 create 方法中定义函数,模板触发防抖或节流函数,然后调用真正要用到的逻辑</p><h2 id="Class-和-Style-的绑定"><a href="#Class-和-Style-的绑定" class="headerlink" title="Class 和 Style 的绑定"></a>Class 和 Style 的绑定</h2><p>class 的绑定支持用数组或者对象来</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span>  <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>static<span class="token punctuation">"</span></span>  <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>&amp;#123; active: isActive, <span class="token punctuation">'</span>text-danger<span class="token punctuation">'</span>: hasError &amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>classObject<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>[activeClass, errorClass]<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      classObject<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        active<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token string">'text-danger'</span><span class="token punctuation">:</span> <span class="token boolean">false</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    activeClass<span class="token punctuation">:</span> <span class="token string">'active'</span><span class="token punctuation">,</span>    errorClass<span class="token punctuation">:</span> <span class="token string">'text-danger'</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>由于现在 Vue3 版本组件支持多个根组件,所以,如果给组件设置class,需要组件设置哪个元素接收</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-component</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>baz<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-component</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> app <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">createApp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'my-component'</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`    &lt;p :class="$attrs.class">Hi!&lt;/p>    &lt;span>This is a child component&lt;/span>  `</span></span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span></code></pre><p>使用<code>$attrs.class</code>指定哪个根元素</p><h3 id="style多重值"><a href="#style多重值" class="headerlink" title="style多重值"></a>style多重值</h3><p>可以为 <code>style</code> 绑定中的 <code>property</code> 提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:</span><span class="token style-attr language-css"><span class="token attr-name"><span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value">&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span> <span class="token property">display</span><span class="token punctuation">:</span> [<span class="token string">'-webkit-box'</span>, <span class="token string">'-ms-flexbox'</span>, <span class="token string">'flex'</span>] &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 <code>flexbox</code>，那么就只会渲染 <code>display: flex</code>。</p><h2 id="新增组合式API"><a href="#新增组合式API" class="headerlink" title="新增组合式API"></a>新增组合式API</h2><h3 id="setup方法"><a href="#setup方法" class="headerlink" title="setup方法"></a><code>setup</code>方法</h3><blockquote><p><code>setup</code> 选项是一个接收 <code>props</code> 和 <code>context</code> 的函数，我们将在之后进行讨论。此外，我们将 <code>setup</code> 返回的所有内容都暴露给组件的其余部分 (计算属性、方法、生命周期钩子等等) 以及组件的模板。<br>在 <code>setup</code> 中你应该避免使用 <code>this</code>，因为它不会找到组件实例。<code>setup</code> 的调用发生在 <code>data property</code>、<code>computed property</code> 或 <code>methods</code> 被解析之前，所以它们无法在 <code>setup</code> 中被获取。<br><code>setup</code> 函数中的第一个参数是 <code>props</code>。正如在一个标准组件中所期望的那样，<code>setup</code> 函数中的 <code>props</code> 是响应式的，当传入新的 <code>prop</code> 时，它将被更新.但是，因为 <code>props</code> 是响应式的，你不能使用 <code>ES6</code> 解构，它会消除 <code>prop</code><br>如果需要解构 <code>prop</code>，可以在 <code>setup</code> 函数中使用 <code>toRefs</code> 函数来完成此操作：<br>如果 <code>title</code> 是可选的 <code>prop</code>，则传入的 <code>props</code> 中可能没有 <code>title</code> 。在这种情况下，<code>toRefs</code> 将不会为 <code>title</code> 创建一个 <code>ref</code> 。你需要使用 <code>toRef</code> 替代它：</p></blockquote><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> toRefs<span class="token punctuation">,</span> toRef  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token function">setup</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> title <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token operator">=</span> <span class="token function">toRefs</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> name <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token operator">=</span> <span class="token function">toRef</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>title<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="Context参数"><a href="#Context参数" class="headerlink" title="Context参数"></a>Context参数</h3>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# EncoderParameter使用注意事项</title>
      <link href="2022/03/03/bug-notes-2022-03-03-c-encoderparameter-shi-yong-zhu-yi-shi-xiang/"/>
      <url>2022/03/03/bug-notes-2022-03-03-c-encoderparameter-shi-yong-zhu-yi-shi-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ul><li>使用<code>System.Drawing.Image.Save</code>将一个png图片保存为tif格式的图片, 老是遇到 <code>params is not valid</code> 错误</li></ul><p>这个方法我使用的是<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.image.save?view=dotnet-plat-ext-6.0#System_Drawing_Image_Save_System_String_System_Drawing_Imaging_ImageCodecInfo_System_Drawing_Imaging_EncoderParameters_">这个重载</a></p><p>第二个参数好理解,就是指定输出MimeType, 第三个就不好理解了</p><p>意思大概是用什么质量, 色域去输出</p><pre class=" language-c#"><code class="language-c#">ImageCodecInfo tiffImageCodecInfo = ImageCodecInfo.GetImageEncoders().FirstOrDefault(f => f.MimeType == "image/tiff");//ImageCodecInfo pngImageCodecInfo = ImageCodecInfo.GetImageEncoders().FirstOrDefault(f => f.MimeType == "image/png");EncoderParameters myEncoderParameters = new(2);myEncoderParameters.Param[0] = new EncoderParameter(Encoder.Compression, (long)EncoderValue.CompressionLZW);myEncoderParameters.Param[1] = new EncoderParameter(Encoder.Quality, 0L);using Image png = Image.FromFile(inputFile);png.Save(outputFile, ImageFormat.Tiff);png.Save(outputCompressionFile, tiffImageCodecInfo, myEncoderParameters);Console.WriteLine("Hello World!");</code></pre><p>附上我成功的代码,之前一直失败就是因为<code>new EncoderParameter</code>构造函数里面的第二个参数有问题,我是直接写<code>int</code>类型的(而且还不知道填什么数好,后面又用了个<code>EncoderValue</code>枚举去输入),这里其实参考上面的链接,里面有个细节就是例子都是用了<code>long</code>类型的,所以我们这里也是要同理的,最后在windows上成功了,发布到<code>Linux</code>居然压缩没什么变化,无语了,等找到解决方法再更新</p>]]></content>
      
      
      <categories>
          
          <category> bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLR-via-第10章-属性</title>
      <link href="2021/12/23/read-notes-clr-via-2021-12-23-clr-via-di-10-zhang-shu-xing/"/>
      <url>2021/12/23/read-notes-clr-via-2021-12-23-clr-via-di-10-zhang-shu-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="第10章-属性"><a href="#第10章-属性" class="headerlink" title="第10章 属性"></a>第10章 属性</h2><h3 id="1-无参属性"><a href="#1-无参属性" class="headerlink" title="1.无参属性"></a>1.无参属性</h3><blockquote><p>面向对象设计和编程的重要原则之一就是数据封装.意味着类型的字段永远不应该公开, 否则很容易因为不恰当使用字段而破坏对象的状态.</p><ul><li><p>还有你可能希望访问字段执行一些副作用, 缓存某些值或者时推迟创建一些内部对象</p></li><li><p>你可能希望以线程安全的方式访问字段</p></li><li><p>字段可能是一个逻辑字段,它的值不由内存中的字节表示, 而是通过某个算法来计算获取</p></li></ul></blockquote><p>所以c#和CLR为了解决以上问题点,提供了一种叫属性的东西</p><ul><li><p>本质上属性是方法,编译器在背后帮你生成了对某个字段获取和编辑的方法</p></li><li><p>编译器会在托管程序集的元数据中生成了一个属性的定义项,包括一些标志(flags)以及属性的类型,这些信息的作用就是在属性这种抽象概念于它的访问器之间建立一个联系.编译器和其他工具就可以利用这种元数据信息. 但是CLR不使用这种元数据信息,在运行时只需要访问器方法</p></li></ul><h4 id="对象和集合初始化器"><a href="#对象和集合初始化器" class="headerlink" title="对象和集合初始化器"></a>对象和集合初始化器</h4><pre class=" language-c#"><code class="language-c#">Emplyee e = new Emplyee&#123;    Name = "Jeff",    Age = 45&#125;List<string> arr = new List<string>&#123;    "1","2","3"&#125;</code></pre><p>上述的初始化本质是编译器帮你调用构造器,再手动帮你给每个属性赋值,但是这样子写增强了代码的可读性;集合的就是帮你add</p><h4 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h4><pre class=" language-c#"><code class="language-c#">var o = new &#123;    Name = "张三"&#125;</code></pre><p>这里是一个匿名的类型,编译器会推断每个表达式的类型, 创建推断类型的私有字段, 为每个字段创建公共只读属性,并创建一个构造器来接受所有这些表达式. 除此之外,编译器还会重写<code>Object</code>的<code>Equal</code>,<code>GetHashCode</code>和<code>ToString</code>方法</p><ul><li>编译器在定义匿名类型时是非常智能的, 假如你在代码中定义了多个匿名类型,并具有相同的结构,,那它只会创建一个匿名类型定义, 但是创建该类型的多个实例.</li></ul><h4 id="System-Tuple-元组-和-System-ValueTuple"><a href="#System-Tuple-元组-和-System-ValueTuple" class="headerlink" title="System.Tuple 元组 和 System.ValueTuple"></a>System.Tuple 元组 和 System.ValueTuple</h4><ul><li><p>Tuple是引用类型,ValueTuple是值类型</p></li><li><p>Tuple创建好之后就不能修改其属性(是只读的),ValueTuple是创建好之后还可以修改</p></li></ul><h3 id="2-有参属性"><a href="#2-有参属性" class="headerlink" title="2.有参属性"></a>2.有参属性</h3><p>当属性的get访问器方法接受一个或多个参数, 这时候就可以称为索引器了</p><blockquote><p>CLR本身不区分无参属性和有参属性, 对于CLR来说,每个属性都是类型中定义的一对方法和一些元数据.c#团队将<code>this[...]</code>作为表达索引器的语法,所以c#只允许在对象的实例上定义索引器.c#不支持定义静态索引器属性, 虽然CLR是支持静态有参属性的</p></blockquote><h3 id="3-调用属性访问器方法时的性能"><a href="#3-调用属性访问器方法时的性能" class="headerlink" title="3.调用属性访问器方法时的性能"></a>3.调用属性访问器方法时的性能</h3><p>JIT会将get,set访问器方法内联(或者说嵌入), 这样一来,使用属性就没有性能上的损失.内敛是指将方法直接编译到调用它的方法中,避免在运行时发出调用产生开销</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
            <tag> clr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLR-via-第9章 参数</title>
      <link href="2021/12/22/read-notes-clr-via-2021-12-22-clr-via-di-9-zhang-can-shu/"/>
      <url>2021/12/22/read-notes-clr-via-2021-12-22-clr-via-di-9-zhang-can-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="第9章-参数"><a href="#第9章-参数" class="headerlink" title="第9章 参数"></a>第9章 参数</h2><h3 id="1-可选参数和命名参数"><a href="#1-可选参数和命名参数" class="headerlink" title="1.可选参数和命名参数"></a>1.可选参数和命名参数</h3><ul><li><p>可以为方法,构造器方法和有参属性的参数指定默认值, 还可以为属于委托定义的一部分的参数指定默认值</p></li><li><p>有默认值的参数必须放在没有默认值的所有参数之后</p></li><li><p>默认值必须是编译时能确定的常量值</p></li><li><p>小心重命名,因为上层调用指定了变量名的话,也要重构(使用重命名后的名字)</p></li><li><p>如果参数用<code>ref</code>或<code>out</code>关键字进行了标识,就不能设置默认值</p></li></ul><p>一旦为参数分配了默认值,编译器就会在内部向该参数应用定制特性<code>System.Runtime.InteropServices.OptionalAttribute</code>这个特性, 这个最终会保存到元数据中.此外,编译器还会将这个值设置 <code>System.Runtime.InteropServices.DefaultParameterValueAttribute</code>的构造器传递你在代码写的常量值</p><p>之后,编译器调用方法,发现缺少某部分实参,就会从元数据中提取值,并将值自动嵌入到调用中</p><h3 id="2-隐式类型的局部变量"><a href="#2-隐式类型的局部变量" class="headerlink" title="2.隐式类型的局部变量"></a>2.隐式类型的局部变量</h3><p>在声明变量的时候,我们一般要先定义这个变量的类型, 但是c#3之后提供了一个匿名类型也就是<code>var</code>, 这个意思和JavaScript的var完全不一样,这个是由c#编译器推断类型,并不是动态类型,这一点是最重要的</p><ul><li>不能用在方法参数声明中</li></ul><h3 id="3-以传引用的方式向方法传递参数"><a href="#3-以传引用的方式向方法传递参数" class="headerlink" title="3.以传引用的方式向方法传递参数"></a>3.以传引用的方式向方法传递参数</h3><blockquote><p>CLR默认所有方法参数都传值. 传递引用类型的对象时,对象引用(或者说指向对象的指针)被传给方法. 注意引用(或指针)本身时传值的,意味着方法能修改对象,而调用者能看到这些修改.对于值类型的实例,传给方法的时实例的一个副本,意味着方法将获得它专用的一个值类型的实例副本,调用者中的实例不受影响.<br>CLR 允许以传引用而非传值的方式传递参数. c#用关键字<code>ref</code>和<code>out</code>支持了这个功能.两个关键字都告诉c#编译器生成元数据来指明该参数是传引用的.编译器将生成代码来传递参数的地址,而非参数本身</p></blockquote><ul><li><p>CLR 不区分<code>ref</code>和<code>out</code>,无论使用哪个关键字,生成的IL都是一样的,元数据也几乎完全一样,除了一个bit除外,它用于记录声明方法时指定是<code>ref</code>还是<code>out</code>.</p></li><li><p><code>ref</code>要先初始化参数的字,<code>out</code>参数是未必初始化好了值</p></li><li><p>为大的值类型使用<code>out</code>, 可提升代码的执行效率, 因为它避免了在进行方法调用时复制值类型的字段</p></li><li><p>CLR 允许根据使用的是<code>ref</code>和<code>out</code>参数对方法进行重载,如下例</p></li></ul><pre class=" language-c#"><code class="language-c#">public sealed class Point&#123;    static void Add(Point p)&#123;&#125;    static void Add(ref Point p)&#123;&#125;&#125;</code></pre><p>但是两个重载方法只有<code>ref</code>和<code>out</code>的区别则不合法,因为两个签名的元数据形式完全心相通, 所以不能在例子中定义这样的方法<code>static void Add(out Point p)&#123;&#125;</code></p><h3 id="4-可变参数"><a href="#4-可变参数" class="headerlink" title="4.可变参数"></a>4.可变参数</h3><ul><li>只能是方法中的最后一个参数,使用<code>params</code>作为关键字</li></ul><p><code>params</code>关键字告诉了编译器向参数引用定制特性<code>System.ParamArrayAttribute</code>,编译器会把可变参数转为一个数组</p><p>可变参数对比没有用可变参数的方法,在性能上有一定影响,毕竟数组元素也要初始化,要在堆上分配内存,最后要垃圾回收.可以考虑定义几个没有使用<code>params</code>关键字的重载版本</p><h3 id="5-参数和返回类型的设计规范"><a href="#5-参数和返回类型的设计规范" class="headerlink" title="5.参数和返回类型的设计规范"></a>5.参数和返回类型的设计规范</h3><ul><li><p>声明方法的参数类型时,应尽量指定最弱的类型,宁要接口也不要基类, 比如使用<code>IEnumerable&lt;T&gt;</code>声明参数比<code>List&lt;T&gt;</code>要好,这样,方法的适用性好点</p></li><li><p>方法的返回类型恰好相反, 一般最好将方法的返回类型声明为最强的类型(防止受限于特定类型)</p></li></ul><h3 id="6-常量性"><a href="#6-常量性" class="headerlink" title="6.常量性"></a>6.常量性</h3><p>c#和CLR都不支持</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
            <tag> clr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLR-via-第8章 方法</title>
      <link href="2021/12/20/read-notes-clr-via-2021-12-20-clr-via-di-8-zhang-fang-fa/"/>
      <url>2021/12/20/read-notes-clr-via-2021-12-20-clr-via-di-8-zhang-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="第8章-方法"><a href="#第8章-方法" class="headerlink" title="第8章 方法"></a>第8章 方法</h2><h3 id="1-实例构造器和类-引用类型"><a href="#1-实例构造器和类-引用类型" class="headerlink" title="1. 实例构造器和类(引用类型)"></a>1. 实例构造器和类(引用类型)</h3><ul><li>什么是实例构造器?</li></ul><p>说人话就是ctor,构造函数</p><ul><li>构造器做什么</li></ul><blockquote><p>它是在创建引用类型实例的时候,首先未实例的数据字段分配内存,然后初始化对象的附加字段(类型对象指针和同步块索引), 最后调用类型的的实例构造器来设置对象的初始状态</p></blockquote><ul><li>构造器和普通方法的不同之处</li></ul><p>它不能被继承,一个类只有自己定义的实例构造器. 由于不能继承实例构造器, 所以实例构造器不能使用以下修饰符: <code>virtual</code> , <code>new</code>, <code>override</code>, <code>sealed</code>, <code>abstract</code></p><ul><li><p>编译器在没有显式定义任何构造器的情况下,自动定义一个默认的无参的构造器,默认是<code>public</code>,如果类的修饰符是<code>static</code>(<code>sealed</code>和<code>abstract</code>)<a href="%E9%9D%99%E6%80%81%E7%B1%BB%E5%9C%A8%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%98%AF%E6%8A%BD%E8%B1%A1%E5%AF%86%E5%B0%81%E7%B1%BB">^1</a>,编译器不会生成默认的构造器</p></li><li><p>如果类的修饰符有<code>abstarct</code>的话,编译器生成的默认构造函数的可访问性就为<code>protected</code>,如果基类没有提供无参构造器,那么派生类必须显式调用一个基类构造器,否则报错.</p></li></ul><blockquote><p>不要在构造器中调用虚方法, 原因是假如实例化的类型重写虚方法,那么就会执行派生类对虚方法的实现,但是这个时候,尚未完成对继承车层次结构中的所有字段的初始化(被实例化的类型的构造器还没有运行呢),所以,调用虚方法会导致无法预测的行为,归根到底,这是由于调用虚方法时,直到运行时之前都不会选择执行该方法的实际类型</p></blockquote><p>有以下一个类型</p><pre class=" language-c#"><code class="language-c#">public sealed class SomeType&#123;    private int m_x = 5;    public SomeType()    &#123;        //1. m_x = 5;        //2. base.ctor()        //3.自定义的代码        m_x = 10;    &#125;&#125;</code></pre><p>这个<code>SomeType</code>的<code>m_x</code>字段被初始化为了5,这是怎么做到的?</p><blockquote><p>根据IL可知,构造器先把值5存到呢字段<code>m_x</code>,再调用基类的构造器.换句话说,编译器提供了一个简化的语法,允许以内联方法初始化实例字段.但是在幕后,它会将这种语法转换成构造器方法中的代码来执行初始化.</p></blockquote><p>也就说你使用了这种内联的写法,构造器第一步执行内联的赋值,第二步执行基类的构造器,最后执行构造器自己的代码</p><h3 id="2-实例构造器和结构-值类型"><a href="#2-实例构造器和结构-值类型" class="headerlink" title="2. 实例构造器和结构(值类型)"></a>2. 实例构造器和结构(值类型)</h3><ul><li>值类型和引用类型的构造器的不同</li></ul><blockquote><p>CLR总是允许创建值类型的实例, 并且没有办法阻止值类型的实例化. 所以值类型其实不需要定义构造器, 编译器根本不会为值类型内联(嵌入)默认的无参构造器</p></blockquote><p>现在有个一个引用类型, 包含了一个值类型的字段和默认的无参构造器, 当调用构造器的时候,考虑到性能,CLR不会为包含在引用类型中的每个值类型字段都主动调用构造器.所以值类型的字段会被初始化为0或null</p><p>CLR也允许为值类型定义构造器,但是必须显式调用才会执行,也就是主动<code>new</code>.但是编译器是不允许你主动<code>new Point()</code>这样去主动调用一个值类型的无参构造器,实际上如果你写了这样的无参构造器</p><pre class=" language-c#"><code class="language-c#">public struct Point&#123;    public int x,y;    public Point()    &#123;        x = y = 5;    &#125;&#125;</code></pre><p>在编译器中是会直接报错的,会提示</p><blockquote><p>error CS0568: 结构不能包含显示的无参数构造器</p></blockquote><p>因为编译器不会主动调用值类型的无参数构造器,所以为了防止开发人员对这种构造器在什么时候调用产生迷惑,所以编译器永远不会生成自动调用它的代码.值类型的字段总是被初始化为0 或 null</p><ul><li><p>严格的说,值类型的字段只有在嵌套到引用类型中,才能保证被初始化为 0 或null.基于栈的值类型字段则无此保证</p></li><li><p>虽然c#编译器不允许值类型带有无参构造器, 但是CLR是允许的,</p></li></ul><h3 id="3-类型构造器"><a href="#3-类型构造器" class="headerlink" title="3. 类型构造器"></a>3. 类型构造器</h3><p>除了实例构造器, clr还支持类型构造器,也就是俗称的静态构造器</p><p>对应的实例构造器是设置类型的实例的初始状态, 对应的,类型构造器是设置类型的初始状态. 类型默认没有定义类型构造器,如果定义也只能定义一个.此外, 类型构造器永远没有参数</p><pre class=" language-c#"><code class="language-c#">public sealed class SomeType&#123;    static SomeType()&#123;&#125;&#125;</code></pre><p>类型构造器总是私有的,编译器会自动标记为<code>private</code>,之所以必须私有,是为了防止任何由开发人员写的代码调用它,对它的调用总是由CLR负责</p><blockquote><p>类型构造器的调用比较麻烦, JIT编译器在编译一个方法时,会查看代码中都引用了哪些类型. 任何一个类型定义了类型构造器, JIT编译器都会检查针对当前<code>AppDomain</code>,是否已经执行了这个类型构造器.如果构造器从未执行,JIT编译器会在它生成本机(native)代码中添加对类型构造器的调用.如果类型构造器已经执行,JIT编译器就不添加对它的调用,因为它知道类型已经初始化好了.</p><p>事实上,多个线程可能同时执行相同的方法.CLR希望确保在每个<code>AppDomain</code>中, 一个类型构造器只执行一次.为了保证这一点,在调用类型构造器时,调用线程要获取一个互斥线程同步锁.这样一来,如果多个线程视图同时调用某个类型的静态构造器,只有一个线程可以获得锁,其他线程会被阻塞(blocked).第一个线程会执行静态构造器中的代码.当第一个线程离开构造器后,正在等待的线程将会被唤醒,然后发现构造器的代码已被执行过.因此,这些线程不会再次执行代码,将直接从构造器方法返回.除此之外,如果再次调用这样一个方法, CLR知道类型构造器已被执行过,从而确保构造器不被再次调用.</p></blockquote><ul><li><p>单个线程中的两个类型包含互相引用的代码可能出问题</p></li><li><p>静态字段的赋值同理和实例差不多</p></li><li><p>类型构造器不应调用基类的类型构造器, 这种调用之所以没必要,是因为类型不可能有静态字段是从基类型分享或继承的.</p></li></ul><h3 id="4-操作符重载方法"><a href="#4-操作符重载方法" class="headerlink" title="4. 操作符重载方法"></a>4. 操作符重载方法</h3><p>在c#中的操作符重载对于CLR来说都不是不可知的,本质都是调用CLR方法.CLR 规范要求操作符重载方法必须是<code>public</code>和<code>static</code>方法.</p><pre class=" language-c#"><code class="language-c#">public sealed class Complex&#123;    public static Complex operator+(Complex c1, Complex c2)&#123;...&#125;&#125;</code></pre><h3 id="5-转换操作符方法"><a href="#5-转换操作符方法" class="headerlink" title="5. 转换操作符方法"></a>5. 转换操作符方法</h3><p>有时候需要将对象从一种类型转换为另一种类型.当源类型和目标类型都是编译器识别的基元类型时,编译器自己就知道如何生成转换对象所需的代码.</p><p>但是如果不是基元类型,编译器会生成代码,要求CLR执行转换(强制转型),假如你需要这样的转换,可以这样定义转换构造器和方法</p><pre class=" language-c#"><code class="language-c#">public sealed class Rational &#123;    public Rational(int num)&#123;&#125;    public Rational(Single num)&#123;&#125;    public int ToInt()&#123;&#125;    public Single ToSingle()&#123;&#125;&#125;</code></pre><p>事实上,c#还提供了转换操作符重载, 可以使用特殊的语法来定义转换操作符方法.CLR规范要求转换操作符重载方法必须时<code>public</code> 和<code>static</code>.此外,c#要求参数类型和返回类型二者必有其一与定义转换方法的类型相同.之所以要进行这个限制,是为了使c#编译器能在一个合理的时间内找到要绑定的操作符方法</p><pre class=" language-c#"><code class="language-c#">public sealed class Rational &#123;    public Rational(int num)&#123;&#125;    public Rational(Single num)&#123;&#125;    public int ToInt()&#123;&#125;    public Single ToSingle()&#123;&#125;    // 由一个int隐式构造并返回一个Rational    public static implicit operator Rational(int num)&#123;        return new Rational(num);    &#125;    public static implicit operator Rational(Single num)&#123;        return new Rational(num);    &#125;    //由一个Rational显式返回一个int    public static explicit operator int(Rational r)&#123;        return r.ToInt();    &#125;&#125;</code></pre><p><code>implicit</code>关键字告诉编译器为了生成代码来调用方法,不需要再源代码中进行显式转型.相反,<code>explicit</code>告诉了编译器只有再发现了显式转型时,才调用方法</p><p>在<code>implicit</code>和<code>explicit</code>关键字之后,要指定<code>operator</code>关键字告诉编译该方法是一个转换操作符.在<code>operator</code>之后,指定对象要转换成什么类型.在圆括号中,则指定要从什么类型转换.</p><pre class=" language-c#"><code class="language-c#">//使用Rational r1  = 5;//int 隐式转型为Rationalint x = (int)r1;//Rational 显式转型为int</code></pre><ul><li>什么时候改用隐式,什么时候该用显式?</li></ul><blockquote><p>只有在转换不损失精度或数量级的前提下,才能定义隐式转换操作符. 如果转换会造成精度或数量级的损失, 就应该定义一个显式转换操作符. 而且,显式转换失败,应该让显式转换抛出<code>OverflowException</code>或者<code>InvalidOperationException</code></p></blockquote><h3 id="6-扩展方法"><a href="#6-扩展方法" class="headerlink" title="6. 扩展方法"></a>6. 扩展方法</h3><p>扩展方法,故名思意,就是对类型就行扩展的方法.</p><p>一些关于扩展方法的规则</p><ul><li>c#只支持扩展方法,不支持扩展属性,扩展事件,扩展操作符等</li><li>扩展方法(第一个参数前面有this的方法)必须在非泛型的静态类中声明.然而,类名没有限制,可以祟拜你叫什么明细.当然,最重要的,扩展方法至少要有一个参数,而且只有第一个参数能用<code>this</code>关键字标记.</li><li>c#编译器在静态类中查找扩展方法的时候,要求静态类本身必须具有文件作用域,不能是嵌套类</li></ul><p>c#编译器会自动给扩展方法添加一个特性<code>ExtensionAttribute</code>,这个特性会添加到元数据中,这样编译器就可以快速扫描程序集,查找方法</p><h3 id="7-分部方法"><a href="#7-分部方法" class="headerlink" title="7. 分部方法"></a>7. 分部方法</h3><p>一些使用规则</p><ul><li>只能在分部类或结构中声明</li><li>分部方法的返回类型始终是<code>void</code>, 任何参数都不能用out修饰符来标记.</li><li>分部方法的声明和实现必须具有完全一致的签名.如果两者都引用了定制特性,编译器会合并两个方法的特性.应用于参数的任何特性也会合并</li><li>如果没有对应的实现部分, 便不能在代码中创建一个委托来引用这个分部方法</li><li>分部方法总是被视为<code>private</code>,但是c#编译器禁止在分部方法声明之前添加<code>private</code>关键字</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
            <tag> clr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLR via 第7章常量和字段</title>
      <link href="2021/12/16/read-notes-clr-via-2021-12-16-clr-via-di-7-zhang-chang-liang-he-zi-duan/"/>
      <url>2021/12/16/read-notes-clr-via-2021-12-16-clr-via-di-7-zhang-chang-liang-he-zi-duan/</url>
      
        <content type="html"><![CDATA[<h2 id="常量和字段"><a href="#常量和字段" class="headerlink" title="常量和字段"></a>常量和字段</h2><h3 id="常量几个重要知识"><a href="#常量几个重要知识" class="headerlink" title="常量几个重要知识"></a>常量几个重要知识</h3><ul><li><p>常量是指值从不变化的符号,它的值总是在编译时就确定</p></li><li><p>编译器会将常量保存到程序集的元数据中(题外话,程序集,元数据都保存了什么,请看其他章节)</p></li><li><p>一般常量会定义为基元类型,但是c#允许定义为自定义类型,前提是把值设置为<code>null</code></p></li><li><p>由于常量不变化,所以常量被视为类型定义的一部分,也就是静态成员,而不是实例成员,隐式的静态成员,所以c#不允许为常量指定为<code>static</code></p></li><li><p>编译器在程序集的元数据查找该符号,会将值直接签入到<code>IL</code>中,所以在运行中不需要为它分配内存,所以也不能获取常量的内存地址</p></li><li><p>引用的程序集中的常量对本程序集的影响</p><ul><li>假如在b.dll中定义了一个类型是<code>int</code>的常量b,b的值是50</li><li>a引用了b,在a生成的时候就确定了b的值,</li><li>b修改了,常量的值,但是如果a,没有重新编译,使用的也还是旧值,想获得新值,也必须重新编译</li></ul></li></ul><blockquote><p>如果希望在运行时从一个程序集中提取另外一个程序集中的值,那不应该使用常量,应该使用<code>readonly</code></p></blockquote><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><blockquote><p>字段是一种数据成员,其中容纳了一个值类型的实例或者对一个引用类型的引用</p></blockquote><table><thead><tr><th>CLR术语</th><th>c#术语</th><th>说明</th></tr></thead><tbody><tr><td>Static</td><td>static</td><td>这种字段是类型状态的一部分,而不是对象状态的一部分</td></tr><tr><td>Instance</td><td>默认</td><td>这种字段与类型的一个实例关联,而不是与类型本身关联</td></tr><tr><td>InitOnly</td><td>readonly</td><td>这种字段只能由一个构造器方法中的代码写入</td></tr><tr><td>Volatile</td><td>volatile</td><td>编译器,CLR和硬件不会对访问这种字段的代码执行”线程不安全”的优化措施,只有以下类型才能标志为<code>volatile</code>, 所有的引用类型,Single, Boolean, Byte, SByte, Int16, Int32, UInt16, Uint32, Char等等(太长不抄了)</td></tr></tbody></table><ul><li>大多数字段都是read/write字段,意味着在代码执行过程中,字段值可以多次改变. 但<code>readonly</code> 字段只能在构造器方法中写入. 构造器方法只能调用一次,就是对象创建的时候,编译器和验证机制会确保readonly字段不会被构造器以外的任何方法写入,但是,<strong>可以用反射去修改</strong></li></ul><blockquote><p>当某个字段是引用类型,并且该字段被标记为<code>readonly</code>时,不可变的是引用,而非<strong>字段引用的对象</strong>, 也就说引用对象必须是这个对象,但是对象里面的值怎么变都可以</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CLR </tag>
            
            <tag> c# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.net 使用IObservable&lt;T&gt;和IObserver&lt;T&gt; 实现观察者模式</title>
      <link href="2021/12/02/study-notes-c-2021-12-02-net-shi-yong-iobservable-t-he-iobserver-t-shi-xian-guan-cha-zhe-mo-shi/"/>
      <url>2021/12/02/study-notes-c-2021-12-02-net-shi-yong-iobservable-t-he-iobserver-t-shi-xian-guan-cha-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-观察者模式是什么"><a href="#1-观察者模式是什么" class="headerlink" title="1. 观察者模式是什么?"></a>1. 观察者模式是什么?</h1><p>当一个对象被修改时，则会自动通知依赖它的对象。这时候我们就可以使用观察者模式了<br>很简单的一个列子, 拍卖东西, 当拍卖价格(变化的类)发生变化, 那拍卖员(通知类)就要通知所有参加拍卖的人(观察者)</p><h1 id="2-IObservable和IObserver-是什么"><a href="#2-IObservable和IObserver-是什么" class="headerlink" title="2. IObservable和IObserver 是什么"></a>2. IObservable<T>和IObserver<T> 是什么</h1><p><code>IObservable&lt;T&gt;</code> 接口是定义基于推送的通知的提供程序。<br><code>IObserver&lt;T&gt;</code> 接口是提供用于接收基于推送的通知的机制。</p><p>说白了就是.net 给我们提供一个实现观察者模式的接口定义,分别定义了观察者模式中的两种对象, 一个是观察者自己,第二个是 主题类(会发生变化的对象)</p><p>下面都是微软的文档的代码, 加上我自己的理解</p><ul><li>第一步我们定义一个信息类,它包含了一些信息</li></ul><pre class=" language-c#"><code class="language-c#">public struct Location&#123;   double lat, lon;   public Location(double latitude, double longitude)   &#123;      this.lat = latitude;      this.lon = longitude;   &#125;   public double Latitude   &#123; get &#123; return this.lat; &#125; &#125;   public double Longitude   &#123; get &#123; return this.lon; &#125; &#125;&#125;</code></pre><p>这里有个包含位置信息的结构,有经度纬度</p><ul><li>第二步我们使用<code>IObservable&lt;T&gt;</code>来定义一个位置跟踪类, 这个类会在位置变化的时候发送通知</li></ul><pre class=" language-c#"><code class="language-c#">public class LocationTracker : IObservable<Location>&#123;    //私有集合用来存储观察者们   private List<IObserver<Location>> observers;   public LocationTracker()   &#123;      //初始化集合      observers = new List<IObserver<Location>>();   &#125;   // 微软文档中最精妙的地方,很好的利用的c#的特性,普通的观察者实现中肯定是要有个取消订阅的方法的,但是这个没有, 重点就是返回了一个实现了IDisposable接口的对象, 而这个实现了IDisposable接口的对象是一个嵌套类,这样观察者的释放就只能由被观察对象本身释放,不会轻易被外部修改, 提高了健壮性   public IDisposable Subscribe(IObserver<Location> observer)   &#123;      if (! observers.Contains(observer))         observers.Add(observer);      return new Unsubscriber(observers, observer);   &#125;// 嵌套类, 嵌套类不能直接访问包含类   private class Unsubscriber : IDisposable   &#123;      private List<IObserver<Location>>_observers;      private IObserver<Location> _observer;      public Unsubscriber(List<IObserver<Location>> observers, IObserver<Location> observer)      &#123;         this._observers = observers;         this._observer = observer;      &#125;      public void Dispose()      &#123;         if (_observer != null && _observers.Contains(_observer))            _observers.Remove(_observer);      &#125;   &#125;//当位置发生变化时,向所有观察者发布消息   public void TrackLocation(Nullable<Location> loc)   &#123;      foreach (var observer in observers) &#123;         if (! loc.HasValue)            observer.OnError(new LocationUnknownException());         else            observer.OnNext(loc.Value);      &#125;   &#125;//当被观察对象都结束传播, 那通知对象自然就要清除相关观察者   public void EndTransmission()   &#123;      foreach (var observer in observers.ToArray())         if (observers.Contains(observer))            observer.OnCompleted();      observers.Clear();   &#125;&#125;</code></pre><ul><li>第三个观察者类</li></ul><pre class=" language-c#"><code class="language-c#">public class LocationReporter : IObserver<Location>&#123;   private IDisposable unsubscriber;   private string instName;//观察者标识   public LocationReporter(string name)   &#123;      this.instName = name;   &#125;   public string Name   &#123;  get&#123; return this.instName; &#125; &#125;//订阅,实际使用调用通知对象的订阅方法,并且获取了发布中的私有对象   public virtual void Subscribe(IObservable<Location> provider)   &#123;      if (provider != null)         unsubscriber = provider.Subscribe(this);   &#125;//完成,之后,再取消订阅   public virtual void OnCompleted()   &#123;      Console.WriteLine("The Location Tracker has completed transmitting data to &#123;0&#125;.", this.Name);      this.Unsubscribe();   &#125;//发生错误   public virtual void OnError(Exception e)   &#123;      Console.WriteLine("&#123;0&#125;: The location cannot be determined.", this.Name);   &#125;//发生变化时的处理   public virtual void OnNext(Location value)   &#123;      Console.WriteLine("&#123;2&#125;: The current location is &#123;0&#125;, &#123;1&#125;", value.Latitude, value.Longitude, this.Name);   &#125;//取消订阅, 通过IDisposable对象的关联,可以把自身在通知对象中的引用清除,这样就实现了取消订阅   public virtual void Unsubscribe()   &#123;      unsubscriber.Dispose();   &#125;&#125;</code></pre><p>总结: 通过一个<code>IDisposable</code> 和 嵌套对象,巧妙的结合,充分发挥了c#的语言特性,优雅的实现了观察者和被观察者,值得学习.</p><p>引用链接:</p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.iobserver-1?view=net-6.0"><code>IObserver&lt;T&gt; 接口</code></a></p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.iobservable-1?view=net-6.0"><code>IObservable&lt;T&gt; 接口</code></a></p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/nested-types">嵌套类型</a></p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
            <tag> 观察者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>表达式树一些简单应用</title>
      <link href="2021/11/23/study-notes-c-2021-11-23-biao-da-shi-shu-yi-xie-jian-dan-ying-yong/"/>
      <url>2021/11/23/study-notes-c-2021-11-23-biao-da-shi-shu-yi-xie-jian-dan-ying-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="表达式树的一些简单应用"><a href="#表达式树的一些简单应用" class="headerlink" title="表达式树的一些简单应用"></a>表达式树的一些简单应用</h1><h2 id="1-表达式树是什么"><a href="#1-表达式树是什么" class="headerlink" title="1. 表达式树是什么"></a>1. 表达式树是什么</h2><p>表达式树以树形数据结构表示代码，其中每一个节点都是一种表达式，比如方法调用和 <code>x &lt; y</code> 这样的二元运算等。<br>coder可以对表达式树中的代码进行编辑和运算,这样能动态的修改可执行的代码.<br>更多请看<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/expression-trees">微软文档</a></p><h2 id="2-执行表达式树"><a href="#2-执行表达式树" class="headerlink" title="2. 执行表达式树"></a>2. 执行表达式树</h2><p>执行表达式树可能返回一个值，或者它可能只是执行操作，例如调用方法。<br>仅可以执行表示 lambda 表达式的表达式树。 表示 Lambda 表达式的表达式树的类型为 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.linq.expressions.lambdaexpression">LambdaExpression</a> 或 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.linq.expressions.expression-1"><code>Expression&lt;TDelegate&gt;</code></a>。 若要执行这些表达式树，请调用 <code>Compile</code> 方法来创建一个可执行的委托，然后调用该委托。</p><blockquote><p>如果委托的类型未知，也就是说 Lambda 表达式的类型为 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.linq.expressions.lambdaexpression">LambdaExpression</a>，而不是 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.linq.expressions.expression-1"><code>Expression&lt;TDelegate&gt;</code></a>，则必须对委托调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.delegate.dynamicinvoke">DynamicInvoke</a> 方法，而不是直接调用委托。</p></blockquote><blockquote><p>表达式树 是表示一些代码的数据结构。 它不是已编译且可执行的代码。 如果想要执行由表达式树表示的 .NET 代码，则必须将其转换为可执行的 IL 指令。</p></blockquote><blockquote><p>可以将任何 <code>LambdaExpression</code> 或派生自 <code>LambdaExpression</code> 的任何类型转换为可执行的 IL。 其他表达式类型不能直接转换为代码。 此限制在实践中影响不大。 Lambda 表达式是你可通过转换为可执行的中间语言 (IL) 来执行的唯一表达式类型。 （思考直接执行 <code>ConstantExpression</code> 意味着什么。 这是否意味着任何用处？）<code>LambdaExpression</code> 或派生自 <code>LambdaExpression</code> 的类型的任何表达式树均可转换为 IL。 表达式类型 <code>Expression&lt;TDelegate&gt;</code>是 .NET Core 库中的唯一具体示例。 它用于表示映射到任何委托类型的表达式。 由于此类型映射到一个委托类型，因此 .NET 可以检查表达式，并为匹配 lambda 表达式签名的适当委托生成 IL。</p></blockquote><blockquote><p>在大多数情况下，这将在表达式和其对应的委托之间创建简单映射。 例如，由 <code>Expression&lt;Func&lt;int&gt;&gt;</code> 表示的表达式树将被转换为 <code>Func&lt;int&gt;</code> 类型的委托。 对于具有任何返回类型和参数列表的 Lambda 表达式，存在这样的委托类型：该类型是由该 Lambda 表达式表示的可执行代码的目标类型。</p></blockquote><blockquote><p><code>LambdaExpression</code> 类型包含用于将表达式树转换为可执行代码的 <code>Compile</code> 和 <code>CompileToMethod</code> 成员。 <code>Compile</code> 方法创建委托。 <code>CompileToMethod</code> 方法通过表示表达式树的已编译输出的 IL 更新 <code>MethodBuilder</code> 对象。 请注意，<code>CompileToMethod</code> 仅在完整的桌面框架中可用，不能用于 .NET Core。</p></blockquote><blockquote><p>还可以选择性地提供 <code>DebugInfoGenerator</code>，它将接收生成的委托对象的符号调试信息。 这让你可以将表达式树转换为委托对象，并拥有生成的委托的完整调试信息。</p></blockquote><p>需要注意:<br>通过调用在调用 LambdaExpression.Compile() 时创建的委托来执行代码。 可以在上面进行查看，其中 add.Compile() 返回了一个委托。 通过调用 func() 调用该委托将执行代码。</p><p>该委托表示表达式树中的代码。 可以保留该委托的句柄并在稍后调用它。 不需要在每次想要执行表达式树所表示的代码时编译表达式树。 （请记住，表达式树是不可变的，且在之后编译同一表达式树将创建执行相同代码的委托。）</p><p>在此提醒你不要通过避免不必要的编译调用尝试创建用于提高性能的任何更复杂的缓存机制。 比较两个任意的表达式树，以确定如果它们表示相同的算法，是否也会花费很长的时间来执行。 你可能会发现，通过避免对 LambdaExpression.Compile() 的任何额外调用所节省的计算时间将多于执行代码（该代码确定可导致相同可执行代码的两个不同表达式树）所花费的时间。</p><p>上面是从微软文档复制,我个人认为大意就是说比较两个表达式是否相同的算法大概比直接编译还慢,干脆不要用</p><p>另外要注意的,<br>将 lambda 表达式编译为委托并调用该委托是可对表达式树执行的最简单的操作之一。 但是，即使是执行这个简单的操作，也存在一些必须注意的事项。</p><p>Lambda 表达式将对表达式中引用的任何局部变量创建闭包。 必须保证作为委托的一部分的任何变量在调用 <code>Compile</code> 的位置处和执行结果委托时可用。</p><p>一般情况下，编译器会确保这一点。 但是，如果表达式访问实现 <code>IDisposable</code> 的变量，则代码可能在表达式树仍保留有对象时释放该对象。</p><p>示例</p><pre class=" language-c#"><code class="language-c#">//使用前先引入System.Linq.Expressions命名空间// The expression tree to execute.  BinaryExpression be = Expression.Power(Expression.Constant(2D), Expression.Constant(3D));  // Create a lambda expression.  Expression<Func<double>> le = Expression.Lambda<Func<double>>(be);  // Compile the lambda expression.  Func<double> compiledExpression = le.Compile();  // Execute the lambda expression.  double result = compiledExpression();  // Display the result.  Console.WriteLine(result);  // This code produces the following output:  // 8</code></pre><p>示例解释:</p><p><code>Expression.Constant()</code> 表示声明了一个常量,然后<code>Expression.Power</code>表示一个幂等运算,那么第一行可以理解为声明一个幂运算,参数是<code>2D</code>和<code>3D</code>.更形象一点,翻译成人话就是<code>() =&gt; (2 ** 3)</code> 声明了一个这样的表达式<br>那第二行的理解就很简单了,就是把这个表达式的类型从<code>BinaryExpression</code>转成<code>Expression&lt;T&gt;</code>类型<br>那么要从表达式转成可以使用的<code>Func</code>就要用到<code>Compile</code>方法了,这样就能得到一个<code>Func</code>了<br>以上例子还是很好理解的</p><h2 id="3-怎么修改表达式树呢"><a href="#3-怎么修改表达式树呢" class="headerlink" title="3. 怎么修改表达式树呢"></a>3. 怎么修改表达式树呢</h2><p>表达式树是不可变的，这意味着不能直接对它们进行修改。 若要更改表达式树，必须创建现有表达式树的副本，创建此副本后，进行必要的更改。 可以使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.linq.expressions.expressionvisitor">ExpressionVisitor</a> 类遍历现有表达式树，以及复制它访问的每个节点。</p><h3 id="1-首先创建一个类"><a href="#1-首先创建一个类" class="headerlink" title="1. 首先创建一个类"></a>1. 首先创建一个类</h3><pre class=" language-c#"><code class="language-c#">public class AndAlsoModifier : ExpressionVisitor  &#123;      public Expression Modify(Expression expression)      &#123;          return Visit(expression);      &#125;      protected override Expression VisitBinary(BinaryExpression b)      &#123;          if (b.NodeType == ExpressionType.AndAlso)          &#123;              Expression left = this.Visit(b.Left);              Expression right = this.Visit(b.Right);              // Make this binary expression an OrElse operation instead of an AndAlso operation.              return Expression.MakeBinary(ExpressionType.OrElse, left, right, b.IsLiftedToNull, b.Method);          &#125;          return base.VisitBinary(b);      &#125;  &#125;</code></pre><p>这个类继承了<code>ExpressionVisitor</code> 并且重写了表示修改<code>AND</code>运算符的方法,这样,就相当于把<code>and</code>修改成了<code>or</code></p><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><pre class=" language-c#"><code class="language-c#">Expression<Func<string, bool>> expr = name => name.Length > 10 && name.StartsWith("G");  Console.WriteLine(expr);  AndAlsoModifier treeModifier = new AndAlsoModifier();  Expression modifiedExpr = treeModifier.Modify((Expression) expr);  Console.WriteLine(modifiedExpr);  /*  This code produces the following output:      name => ((name.Length > 10) && name.StartsWith("G"))      name => ((name.Length > 10) || name.StartsWith("G"))  */</code></pre><p>首先声明了一个表达式,这个表达式是一个带返回值的委托,内容是输入<code>string</code>类型变量,并判断长度是否大于和以G开始.<br>然后调用修改方法,返回了一个新的表达式树,这个新的表达式把and修改成了or</p><h3 id="3-然后是我自己的一些使用心得"><a href="#3-然后是我自己的一些使用心得" class="headerlink" title="3. 然后是我自己的一些使用心得"></a>3. 然后是我自己的一些使用心得</h3><ul><li>先把要生成的lamdba写出来</li><li>开始围绕这个构建表达式树</li></ul><p>比如我有个这样需求, 根据输入的字段查询这个字段== xx, 翻译过来大意就是 w =&gt; w.property == xx , property是属性名,放到平时,我如果预先知道了属性值,那肯定很简单,直接点出属性名就好了,但是这个东西不是预先知道,并且可能有很多个字段要这样操作,那么这时候就是表达式树大派用场的时候了</p><pre class=" language-c#"><code class="language-c#">//首先我们先把lamdba写出来 w => w.property == xx//分析可知,我们需要一个参数 w, 一个属性 property ,一个常量 xx, 还有一个==expressionvar pe = Expression.Parameter(typeof(User), "w");var propertyExpression = Expression.Property(pe,"Name");var constExpression = Expression.Constant("zhangsan");var equalExpression = Expression.Equal(propertyExpression,constExpression);var lamdbaExpression = Expression.Lamdba<Func<User, bool>>(equalExpression, pe); //再调用Complie就可以编译成func了var func = lamdbaExpression.Compile();</code></pre><p>但是一般来说都不可能这么简单就是一个比较相等就行的,还有使用一些方法,比如Contains之类的,<br>这个时候就需要调用方法了, 一般是先获取你要调用方法的mehtodinfo,</p><ul><li>要注意的有,创建 MethodCallExpression</li><li>静态方法,第一个参数一般就是methodinfo,因为不需要实例调用</li><li>实例方法, 第一个参数一般是实例表达式</li><li>扩展方法, this参数位就穿你的扩展对象进去</li><li>泛型方法需要先知道泛型</li></ul><p>大体如此,以后有更多实例再补充</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/expression-trees-execution">执行表达式树</a></p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/expression-trees/how-to-use-expression-trees-to-build-dynamic-queries">基于运行时状态进行查询</a></p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
            <tag> Expression </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>试穿鞋项目总结</title>
      <link href="2021/08/25/project-notes-2021-08-25-shi-chuan-xie-xiang-mu-zong-jie/"/>
      <url>2021/08/25/project-notes-2021-08-25-shi-chuan-xie-xiang-mu-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote><p>最近几个月一直给一个品牌做一个试穿鞋的项目,项目持续了几个月,终于在昨天开始上线了,所以也是时候总结下这个项目了<br>项目主要是方便该品牌在新鞋子开发过程中达成有效的信息化,流程化,提高鞋子试穿测试的效率而进行开发</p></blockquote><h2 id="问题点"><a href="#问题点" class="headerlink" title="问题点"></a>问题点</h2><ol><li>项目的需求调研不充分</li></ol><p>项目的完成时间,最开始定下来是 7 月初就要上线,可以现在已经到 8 月底才上线,其中值得引起我的深思.项目从立项到开始开发,中间过程并不长,只是大致了解完客户大致需要什么功能就匆匆进行开发了,PM 说我们要边开发边调研,没有时间给你全部调研完了再去慢慢搞了.所以项目的进行是非常快的,快是快了,结果就是客户反馈也是有很多调整的,一时说要这样改,一时说要那样改,重复的调整功能也是让人头疼.</p><p>飞快的调研导致的直接后果是后期无数次的调整.所以下一个项目能否充分调研之后再开发呢?可能下一个项目也是很紧张的,未必都能有充裕的时间进行前期的调研,但是我认为有一点起码是可以帮助我们后期少走歪路的.在我们的开发过程中,项目方向和项目设计都定下来之后,非常有必要把方案和客户进行充分沟通,说不行了能不能有效果出来,起码画个饼出来,大家心里起码有点共识:就是我们的设计方案,能否满足客户的需求?比如后期我们又花了很多时间去增加一个数据隔离的需求,这钟需求,其实在一开始就要有这种设计,提前预设,后期都差不多完善的代码里面再修改,中间难免又会出什么幺蛾子.</p><p>本次项目采用了 3 次交付,后面实际交付了 6 次,其中就是客户始终不满意功能实现,认为还有很多需要调整的,而且我们项目的各种奇怪 bug,问题也不少,调整到了 6 期,可以说才是堪堪满足客户的需求</p><ol start="2"><li>项目沟通缺少</li></ol><p>项目细分需求是分给不同的人去做不同的功能模块,有些模块的独立程度高点,独自一人完成,沟通少可以理解,但是某些功能,需要几个人的做的合并在一起的时候,这时候就出现了各种沟通问题,你的功能我不了解,出现问题只能找某人,正巧的是有位同事 A 正好在二期之后离职了,我接手他的代码真是改的痛不欲生.沟通少是一个方面,主要还是我们对项目的印象都是一个比较零散的,没有统一的完整的印象,我不了解你这个东西做出来是干什么的,和我做的有什么关系.各自为政的后果就是耦合的时候出现了很多问题.</p><ol start="3"><li>项目代码设计,实现混乱</li></ol><ul><li><p>设计混乱:<br>设计的混乱体验在很多方面,比如开始的时候,我们每个人都各做各的,各种模块的文件存放位置都是乱来,文件命名也没有统一的规范,更别说代码风格,要求的代码规范了</p></li><li><p>命名混乱:<br>整体项目的变量,方法命名都没有统一的规范,方法的位置,凌乱的不行,各写各的</p></li><li><p>前端库:<br>首先在一个 mvc 的项目中使用 vue 不是说不行,而是没有以包去管理各种前端库,用工程化的思维去管理项目并没有实现,这种很尬尴,前端你引入一个包,我引入一个包,也不知道是什么版本的,引入了哪些东西,整体项目引入的前端库都是处于一种不可控的状态.</p></li><li><p>前端组件化:<br>前端组件化甚少,比如说通用的 <code>Modal</code>,在我参与之前居然就没有人想过做一个通用的组件出来.就拿这个来说,导致了什么后果,后期我们各做各的,模态框的样式非常不统一,有的是这样有的是那样,没有统一样式,然后想改成统一的样式,就让人头都大了,改的地方太多了.还有一点就是 PM 想给每个模态都自动有缩放功能的,但是从来没有关注过下边实现的人采用的技术,乱来的,功能实现没有组件化,导致,代码实现位置也不统一,非常分散.</p></li><li><p>js 和 css 的引入:<br>通用的就在母版页引入,不是通用的就在本视图引入,然后引入也十分混乱,从来没有关注引入的文件究竟出现在生成的视图的那里,没有使用<code>@section script</code>等技术去优化生成的位置.另外有很多可以通用的 css,没有单独的写在通用的 css 文件中,而是直接每个视图都复制一份,<code>&lt;style&gt;&lt;/style&gt;</code>标签的内容,无法想象,一个页面有一个配套的 css 有那么难?特别点名那位离职的同事 A,是不是完全不懂什么叫复用,一个页面的<code>style</code>足足有 200 多行,但是这样也不要单独写一个 css,而是每新建一个视图,都复制过去,我了个去.还有引入类库,他做的那个功能相对独立,完全可以新建一个母版,但是就是没有,全靠复制,绝了.</p></li><li><p>前端的捆绑和压缩:<br>这个做的也非常烂,根本就没有,众所周知,捆绑和压缩能有效提高文件大小,减少请求次数和大小,提高页面加载速度,不做的原因估计我也不知道,不过个人猜想:一可能是 PM 根本就不想做,因为本质这个项目是直接从另外一个项目复制一份出来,修修改改的,导致有大量的遗留问题,比如有些页面用的是 <code>jQuery</code>,有的页面使用了 <code>vue</code>,类库的使用混乱不堪,更别谈捆绑压缩了,二就是我估计其他开发同事根本不懂,所以从来没人想过这个问题,到后面客户反馈页面加载慢,一个页面单单<code>xhr</code>请求就快20+,离谱.</p></li><li><p>前端 js 语法的限制:<br>由于本项目的其他开发者之前一直是为了兼容性,为了在老旧的安卓设备上也能运行网页,所以自断手足,禁止使用 <code>es6</code> 以上的语法来实现 js 功能,实在令人无语.毕竟现在有众多的兼容方式可以去把 <code>es6</code> 语法兼容到 <code>IE11</code> 上.而且我们的项目最后会运行到套壳的谷歌浏览器中,这个谷歌浏览器的版本足足有 84,真不知道限制 js 语法有什么意思.另外前端没有工程化,就意味我们很难通过各种前端工具对我们的代码进行优化,语法检查等操作,前端代码的质量堪忧.</p></li><li><p>前端设计实现功能不理想:<br>有个功能,叫做报告的功能,这个东西有查看,填写,读取其他各个模板内容汇总的功能,而且要在不少的地方使用到.同事 A 最开始是单独做在一个 <code>view</code> 里面的,然后其他 <code>view</code> 引用需要加载到 <code>iframe</code> 中,关键是 <code>iframe</code> 里面足足套了 3 层 <code>iframe</code>,各个模块的耦合混乱,js 的写法也是非常混乱,这种混乱导致我在改同事 A 的代码简直痛不欲生.这个分层方案是 PM 提出来的,本意是在不同的层做不同的事(第一层是统一的数据独写,第二层是只管UI的显示),但是后面调整起来,读取数据和显示数据完全是耦合的,强行分家不可取,特别是UI层的各种互动还是要依赖一些读取数据的 ,后期的出现了一个因为加载顺序而导致的 bug,假如本来就在一个页面(层面)上是很好解决的, 但是涉及到不同的 <code>iframe</code> 的 <code>ajax</code> 请求加载的顺序,导致处理起来异常头疼.</p></li></ul><p>在这个项目里面大量使用了 <code>iframe</code>,特别我们客户提出上传的图片需要可以编辑,裁剪,旋转,填写文字之类的,所以 PM 基于 <code>vant</code> 的 <code>uploader</code> 组件封装了一套上传组件,这个组件的实现也是不理想的,每个组件都要引入一个编辑图片的 <code>iframe</code>,这也可能是导致后期有个功能严重卡顿的原因.后期功能实现中我需要 iframe 引入一个同事 b 做的页面,那个页面里面足足几十个这个图片上传组件,这时候 iframe 已经很多了,然后,用户点击一下下拉框的时候就已经卡到不行,就是页面卡,我看页面占用内存从几十兆飙升到近 200 兆,令人震惊,当然这只是我的分析,事实是不是这样我也不清楚.</p><ul><li><p>前端页面实现问题:<br>在报告中,同事 A 的任务是画个像 excel 表格的页面,如果是我首选肯定是 <code>table</code> 布局了,可是,A 真不知道怎么想的,实现全部用<code>div</code>+<code>flex</code>布局来实现,且不说他们都很喜欢把 css 写到标签上,不喜欢写 <code>css</code>,一个同样的 <code>css</code>,每个标签都有,复用了个寂寞,而且他这个布局,问题多到不行,1.完全没有考虑到不通过屏幕显示,他完全就是在自己屏幕看到可以就 ok 了,客户那边的屏幕大小相差非常大,完全无法自适应布局,比如宽度减少了,文字就应该换行,好家伙,完全不会,要么被遮挡了,要么就不知道换行换到哪里去,2.然后就是 <code>input</code>,还有各个 <code>cell</code> 的高度,居然全是写死的,完全没有考虑到用户输入多了会怎么样.由于上面存在的种种问题,前后足足调整了 4,5 次都没好,最后同事 A 离职了,在客户一再反馈下,终于到了不重构不行的局面.这次重构实现了响应式布局和动态 <code>textarea</code> 高度.同事 A 在实现布局的时候,真是完全就是有什么任务,我就做个任务,完全没有考虑实现的方式是否正确,合理,简直是为了任务做完而做,乱搞.当然,全部怪他也不合理,PM 在布置任务的时候,只会讲解这一块,从来不多说,说了也是说你要实现什么什么功能,而不是你实现这些功能的同时,希望有什么效果,不仅是功能,还有页面的效果,交互的效果,完全没提的.说白了这里的开发都是遵守优先功能实现,至于页面兼容和交互,没人提就当不存在的了.也难怪同事 A 养成这种烂习惯,我自己也被坑过,做东西的时候没有考虑到各种屏幕的适应,结果某个页面到了客户那里就出问题了.</p></li><li><p>另外就是同事 A 的实现逻辑,着实令人头疼,毫无疑问,他的报告的实现是我看过最恶心的实现了,从页面加载开始,每次<code>if</code> <code>else</code>都是靠请求一次后端,有这个数据就这个方法,没有就走那个方法,各种回调嵌套,一环套一环,比北京的环数还多.然后就是没有重复利用 js,有好多不同的报告,但是为了跟上层的 <code>iframe</code> 对接,其实很多方法都是一摸一样的,但是他就是不抽离出来,做成组件也好,混入也好,完全靠复制粘贴,我接手的时候,一个报告改完了,还要同时改好几份,要是不盯紧点,恐怕就漏了.说难听点,他真是为了做而做,这里要一个数据就请求一次,那里要一个方法就复制一次,代码屎山就是这样来的了,这也是我改他代码最头疼的点了[难受想哭]</p></li><li><p>选用类库差,走了很多歪路<br>客户有个需求是制作完报告之后,可以打印报告成为 pdf,于是 PM 就选用了他们之前一直用的 html2canvas,我了个去,这个东西,真的是个天坑.你在网上搜索可能会发现有些博主写了一些坑指南,但是我这里虽说没有遇到,但是我遇到了他们都没有遇到的.<br>a.在我还没有重构之前,有些地方用了 table,但是就是不知道为什么有些 table 的边框没有了,丢了,这个后面只能特别加了个样式,在回调中特别写了一下样式解决<br>b.然后但我全部重构之后,才发现这玩意不支持 table 的边框合并的功能,这导致了某些 <code>table</code> 的边框线条粗,有些边框的线条细,整体观感非常差,前后调整了也是非常久,最后保证了都没有重叠的边框还是出现粗细线条的问题.<br>c.还有打印遇到高度明明传参正确,但是生成的图片并没有对应的高度.<br>d.最恶心的一个东西,就是 textarea 自动换行,他不支持,PM 查了 <code>issue</code>,它的 beta 版 0.8 的时候就支持,然后到最新的反而不支持,最后特地换到 0.8 才可以,<br>e. 有些样式比如<code>border-top</code>这种它最新的不支持,但是 0.8 反而支持,太诡异了<br>前前后后在这个打印上也花费了非常多的时间,老实说我觉得选错类库坑死了.</p></li><li><p>后端设计和实现混乱<br>后端的设计也不敢恭维,项目可以说是比三层架构还少一层,只有<code>Controller</code>和<code>Services</code>两层,直接在这两层操作<code>dbcontext</code>,非常混乱,非常没有层次</p></li><li><p>各种<code>Controller</code>的调用<code>Services</code>全靠<code>new</code>,我的天哪,都在.net core 的时代了,还老是要靠<code>new</code>来构造类实在是太差了,依赖注入都好像不存在一样</p></li><li><p>各个<code>Services</code>都互有依赖,你 new 我,我 new 你,写法不优雅,层次也不清晰</p></li><li><p>有个公共的提供下拉框选项的方法,3,4 十条 case 来判断,一个方法代码又长又臭,还有不少重复多余,你写了一个,也没有告诉别人,后面的人也不会主动找,你写一个 case,我写一个 case,日子一长,整个方法就又长又臭了,</p></li><li><p>大部分代码都是同步方法,性能差,同事 A 甚至不会写异步方法</p></li><li><p>沟通差,开始设计微信发消息做的人使用异步,后面做统一消息配置的人又用同步,同步调异步,懂得都懂,非常危险,一旦使用不当,就会造成死锁,特别是获取异步结果只是单纯的.Result,异步简直多余了一样.</p></li><li><p>同事 A 连<code>IQueryable</code> 和 <code>IEnumerable</code> 都没搞懂,连基本的<code>EF Core</code>机制都没弄懂,<br>非常多这种代码</p></li></ul><pre class=" language-c#"><code class="language-c#">var obj = _db.xxx.Where();if(obj.Any())&#123;    var obj1 = obj.First();&#125;</code></pre><p>熟悉 ef 的人一眼就看出来这里足足同一条数据查了两次,完全多余,这里代码后边压力测试成绩非常难看<br>修改实体的状态还要手动修改,代码冗余,完全可以直接用 db.add/update/delete 解决</p><ul><li><p>不会使用路由,<code>mvc</code> 默认的路由基本就能满足需求,同事 A 每个<code>action</code>都写<code>[Route(&quot;&#123;controller&#125;/MeasuringFoot/&#123;menuParam?&#125;&quot;)]</code>这种东西不知道干什么,多此一举.</p></li><li><p>一开始 <code>services</code> 层的本来是要分接口和实现两个来做的,由于 PM 说我们这项目要快,要精简,所以直接把所有的接口都砍了,非常不好,完全没有遵守依赖倒置原则,瞎写,本来有了接口的话,中间就可以用 <code>AOP</code> 做很多其他操作了,比如后面的接口拦截,完全没有必要每个控制器,服务都手动写一遍那些日志一类东西(虽然也没有,只有错误日志,没有运行日志,对于程序运行情况完全是一个黑盒)</p></li><li><p>后面在跟同事 c 离职交接的时候,本来有接入微信的一块,好像 PM 和做功能的人和对接微信对 <code>OAuth2.0</code> 协议都好像不填了解的样子,导致出现这个微信公众号网页获取 <code>opendid</code> 有没有限制都不清楚,搞了很久,对接什么东西,还要弄懂背后的原理,才能做好</p></li><li><p>另外两位同事做的提交,后端基本没有对数据进行校验,完全就是传进来就直接用,保存失败的时候还是在 ef 保存的知道,很不好</p></li><li><p>同事 A 的一个前端类转实体的时候,快 70 个字段,全部用手动一个一个赋值,从 547 写到 624 行,佩服,恐怕是连 <code>automapper</code> 都没听过的那种,几行代码能做完的事,搞了那么多,代码观感非常差</p></li><li><p>项目的其他人非常非常喜欢写 sql 语句和拼接 sql 去查询,非常不好,虽然把个别字符转义了,但是完全没有参数化的 sql 语句执行还是有很大的风险的</p></li><li><p>有些人对写文件地址拼接还有些不懂,拼接个文件路径还要判断是不是 <code>Linux</code> 环境,明明 <code>Path</code> 拼接自动判断,手动判断运行环境实在多此一举</p></li><li><p>整个项目基本没有对用户输入做危险字符处理,也就是说没有对 <code>xss</code> 攻击进行防范,系统安全性实在不高.</p></li><li><p>另外这里的项目老是死守在 <code>mvc</code> 实在太脱离现在开发, 不是说 <code>mvc</code> 不行,而是你又要 <code>mvc</code>,又要 <code>vue</code>,实在不搭边,特别是这中不需要 <code>seo</code> 的项目,就更应该前后分离</p></li></ul><h2 id="反思问题"><a href="#反思问题" class="headerlink" title="反思问题"></a>反思问题</h2><ol><li><p>话说好,需求总是变化,设计总是为了适应变化而存在的,只有富有弹性,可塑性的设计才能适应需求的快速迭代,虽然不可能直接就开发出一个 <code>abp</code> 一样功能强大的框架,但是参考和学习,比如模块块的思路,仓储,工作单元,依赖注入等概念总是值得我们去研究学习的,只有健壮的设计才能应对复杂的变化,没有的话,感觉上就是一团乱麻了.</p></li><li><p>前端必须工程化,如今的前端也不是什么一个简简单单的写几个 js,css 就能胜任的,必须要有工程化的思维,用工程化的方式去构建一个健全的项目.</p></li><li><p>后端不能将就,减少分层不是精简化项目,增加分层也不是增加项目的复杂层次, 更重要的是要做到对功能的合理划分,应用有良好的隔离,要面向抽象,让各自职责清晰,这样反而是提高项目可维护性.</p></li><li><p>对接其他系统应该做到对其技术了解,不要一知半解,不清楚的情况下就对接, 避免产生未知的问题.对于我本人而言,业界常用<code>OpenId</code> 和<code>OAuth2.0</code>协议多了解.</p></li><li><p>功能的实现应该具有前瞻性,不要为了实现而实现.其导致的后果及其严重,完全没有考虑到功能复用性.由此,在项目开始阶段,各位开发人员就应该对项目的功能场景有足够认知,以便在实现功能前选用合适技术,该抽象的抽象,该提取到公共模块的就提取,而不是中途修改,造成新一块旧一块,日积月累,应用还没出厂身上就全是补丁了.</p></li></ol><p>暂时到此.</p><p>小总结:<br>这次总结更像是对项目过程的吐槽而不是总结,毕竟这个项目中本人真实积累了不少火气,也很希望那两位同事A不要离职,真的不想动他的屎山.<br>反思不足,吐槽有余😂,还是好好警醒自己,不能一直在安逸区.</p><p>2021.9.1</p><h3 id="2021-10-28-更新-糟糕的习惯会影响一生"><a href="#2021-10-28-更新-糟糕的习惯会影响一生" class="headerlink" title="2021-10-28 更新 糟糕的习惯会影响一生"></a>2021-10-28 更新 糟糕的习惯会影响一生</h3><p>最近还在做这个项目,但是最艰难的部分已经过去,现在相对过去好点,但是屎山还是屎山,不会变的,下面列举的一些坏习惯,值得反省,不要因为在舒适区呆久了,就对自己的代码降低要求,同流合污.</p><ol><li>代码风格非常糟糕,基本就是我新增一个方法,想写道哪里就写道哪里,没有一点规划,起的名字也不三不四,不知道这个方法要干什么,乱七八糟. 代码是给人看的,人都难看,别说维护,坏习惯由此可见,屎山第一坨屎</li><li>有些同事,在新文件里面写,简直就是tmd乱来,直接复制旧的,直接加方法,旧的就不管了, 草,几百行js,有用的才一点,这点时间也要省么,倒是那些通用的方法,复制粘贴倒是很爽,也不懂的复用下</li><li>发现有个人改我的查询,我的数据查出来了,他需要查另外一个表组合数据,好家伙,按道理,他查询的数据肯定有个范围,那就是我的数据范围内,就10条,他直接把数据库里面的全查出来,mmp,数据越来越多,查询越来越慢,屎+1</li><li>开发也有vue.min.js,导致很多bug都没人发现,比如有位同事,乱改子组件中prop的数据,原来是想做个默认值,结果直接修改prop的值,基础都不牢固,还有用那压缩的js,大量key错误,传错prop的类型,等等,不胜枚举,特别是新加的首页,我用vue.js看到2w+的报错,掩耳盗铃莫过于此</li><li>开发的细节如此之多,没有可靠的需求分析,新加个人怕不是一周都搞不定需求,看代码里面那堆起名<code>value</code>的变量名,我看到就难受,都不知道什么来的</li><li>没有统一的格式化工具,这个以前也提到过,再吐槽下.</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JQuery使用Promise封装</title>
      <link href="2021/07/29/study-notes-jquery-2021-07-29-jquery-shi-yong-promise-feng-zhuang/"/>
      <url>2021/07/29/study-notes-jquery-2021-07-29-jquery-shi-yong-promise-feng-zhuang/</url>
      
        <content type="html"><![CDATA[<h2 id="2021-7-31号更新"><a href="#2021-7-31号更新" class="headerlink" title="2021-7-31号更新"></a>2021-7-31号更新</h2><p>今天突然发现,原来jquery自己实现了一套promise的机制,本身就支持promise,当然不是浏览器那个,此东西位于<code>Deferred</code>中,可以输入<code>console.dir($.Deferred())</code>查看,</p><p>然后可以这篇文章比较好介绍了Jquery中的Promise是个什么东西.</p><blockquote><p><a href="https://www.cnblogs.com/lvdabao/p/jquery-deferred.html">https://www.cnblogs.com/lvdabao/p/jquery-deferred.html</a></p></blockquote><p>学无止境,</p><hr><blockquote><p>在我们日常的前端请求中,我们可能会经常使用ajax,这也不是什么新鲜的技术,我们一般会使用一些框架封装的,比如jQuery,axios,vue-resource之类的.在这个公司,老是出现这种情况,好几个请求,有些请求要等前面几个完成,有些请求要上一个请求完成之后,根据返回值判断怎么做,一环套一环的,各种callback,回调函数,🤢,于是,打算使用Promise来优化下调用,Primose我就不介绍了,只是会用,原理没有深入.</p></blockquote><p>废话不多说,直接上代码</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//封装一个基于promise的ajax请求</span>jQuery<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置 apDiv</span>    ajaxPromise<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>option<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> url<span class="token punctuation">,</span> type<span class="token punctuation">,</span> data<span class="token punctuation">,</span> global <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token operator">=</span> option<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                url<span class="token punctuation">:</span> url<span class="token punctuation">,</span>                type<span class="token punctuation">:</span> type<span class="token punctuation">,</span>                data<span class="token punctuation">:</span> data<span class="token punctuation">,</span>                global<span class="token punctuation">:</span> global<span class="token punctuation">,</span>                success<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>                error<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    getPromise<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>option<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> url<span class="token punctuation">,</span> data<span class="token punctuation">,</span> global <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token operator">=</span> option<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            $<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                url<span class="token punctuation">:</span> url<span class="token punctuation">,</span>                data<span class="token punctuation">:</span> data<span class="token punctuation">,</span>                global<span class="token punctuation">:</span> global<span class="token punctuation">,</span>                success<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>                error<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    postPromise<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>option<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> url<span class="token punctuation">,</span> data<span class="token punctuation">,</span> global <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token operator">=</span> option<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            $<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                url<span class="token punctuation">:</span> url<span class="token punctuation">,</span>                data<span class="token punctuation">:</span> data<span class="token punctuation">,</span>                global<span class="token punctuation">:</span> global<span class="token punctuation">,</span>                success<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>                error<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol><li><p>主要有两个东西,第一就是扩展jquery,然后调用就可以使用 <code>$.ajaxPromise()</code> 这样子的方式来调用,然后参数使用了解构来获取,global可以忽略,是我项目inject使用的配置,用来配置loading效果的</p></li><li><p>第二个就是 Promise了,这个就不多说了,在成功和失败的回调中调用对应的resolve和reject就行了,easy</p></li></ol><p>今天的内容就到这里,日后要多记录,好记性不如烂笔头</p>]]></content>
      
      
      <categories>
          
          <category> jquery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jquery </tag>
            
            <tag> Promise </tag>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>window10 LTSC 更新版本</title>
      <link href="2021/07/12/other-notes-2021-07-12-window10-ltsc-geng-xin-ban-ben/"/>
      <url>2021/07/12/other-notes-2021-07-12-window10-ltsc-geng-xin-ban-ben/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>公司采购的电脑使用了windows 10 LTSC版本,LTSC版本虽然稳定,但是对于我来说想要安装WSL2和window terminal的用户来说就不太合适了,因为这两个都有window版本的要求<br>以当前的时间2021-7-12来看,最新的LTSC的内部版本其实还是1809,要使用以上两个功能,必须要1903或以上,所以,为了能使用,我必须升级window版本才行</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>这条升级之路可以说是非常不顺利,由于登录账号需要加入域,域账号的很多设置都是不允许你更新的,比如说管理员设置了组策略不给更新,windows update服务没有开启等等.下面我罗列下我还记得的问题,供各位参考</p><h2 id="第一次尝试-企图使用window-update直接更新大版本"><a href="#第一次尝试-企图使用window-update直接更新大版本" class="headerlink" title="第一次尝试, 企图使用window update直接更新大版本"></a>第一次尝试, 企图使用window update直接更新大版本</h2><p>很可惜,这样是不行,只能更新1809版本里面的各种小更新</p><h2 id="使用window易升"><a href="#使用window易升" class="headerlink" title="使用window易升"></a>使用window易升</h2><p>由于我这个是企业版+LTSC,这个直接堵死这条路,易升是无法升级此版本的,一开始我以为是加入域的问题,结果手贱退出了域,然后直接登录不进去系统(我无法使用管理员账号登录)</p><h2 id="使用MediaCreationTool工具"><a href="#使用MediaCreationTool工具" class="headerlink" title="使用MediaCreationTool工具"></a>使用MediaCreationTool工具</h2><p>这个工具是可以为你创建安装合适版本的window,但是我再第一次尝试的时候由于只是想测试下能不能保留我的文件和应用升级,结果不行,后面百度才知道,是需要你升级的目标的系统和你当前的系统都是同一个版本才行(比如说企业版升级到企业版;专业版升级到专业版),最坑地是我第二次打开,就直接报错了,醉了,我也不知道什么原因,折腾许久,哎,此路不通.</p><h2 id="直接安装iso镜像-成功"><a href="#直接安装iso镜像-成功" class="headerlink" title="直接安装iso镜像(成功)"></a>直接安装iso镜像(成功)</h2><p>为了能保留文件和应用,我需要将LTSC的版本号改成专业版,在这里网上的资料很多都是复制的,垃圾,比如说有个是Professional-x64.cab去改的,我试了没有用,或者读者你可以自己试试先,</p><p>然后我在知乎某篇文章找到了神器,叫window版本转换器的东西,一键傻瓜式转换,不过注意此转换不是永久,我重启之后又是企业版LTSC了,而且这个应用也提了,会把你已激活的变成未激活,这个是需要注意的,至于下载地址,我就不放了,都是百度出来的,我下载的文件是<code>Windows10BBYJZHGJ_V1.0_XiTongZhiJia</code>,你可以参考下</p><p>然后转换系统之后,我在msdn i tell you找到了那里最新的1909系统,下载下来,打开iso,双击exe,安装,这次就可以保留我的文件和应用了,当然,为了免责声明还是要提醒你先保存好你的文件和应用.</p><p>漫长的等待之后,安装完成,系统版本1909,专业版,完美,但是我还想更新到2004,所以,易升再次出场,这次就很顺利,没有其他问题,利索地就升级到2004,至于要不要升级到21h1,就看各位小伙伴怎么想了,反正2004已经够我开发用了,我就不折腾了.</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> win </tag>
            
            <tag> windows10 </tag>
            
            <tag> win10 </tag>
            
            <tag> update </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLR via 第4章 类型基础</title>
      <link href="2021/06/25/read-notes-clr-via-2021-06-25-clr-via-yue-du-wen-da-1/"/>
      <url>2021/06/25/read-notes-clr-via-2021-06-25-clr-via-yue-du-wen-da-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>by the way 此文章主要用来记录我阅读过程中记下应该写下来,或者说应该要牢记的知识点</p></blockquote><hr><h1 id="第4章-类型基础"><a href="#第4章-类型基础" class="headerlink" title="第4章: 类型基础"></a>第4章: 类型基础</h1><ol><li>所有类型都是从 <code>System.Object</code> 派生</li></ol><p>新建一个类型,就算不写继承于谁,默认都是继承了 <code>Object</code><br><code>Object</code> 类中包含了 <code>Equals</code> <code>GetHashCode</code> <code>ToString</code> <code>GetType</code> 等几个方法,所以你才能在一般的类中使用这些方法.</p><ol start="2"><li>类型转换</li></ol><blockquote><p>CLR最重要的特性之一就是类型安全, 在运行时,clr总能知道这个对象的类型是什么,调用 GetType 方法就知道,而且GetType不是虚方法,所以一个类型不可能伪装成为另一个类型</p></blockquote><blockquote><p>c#不要求任何特殊语法即可将对象转换为它的任意基类型,因为向基转换被认为是一种安全的隐式转换, 但是相反的,由基类型转向派生类型时c#要求开发人员要进行显示转换,因为这种转换有可能会失败</p></blockquote><ol start="3"><li>使用<code>is</code> 和 <code>as</code> 来转换类型</li></ol><p>可以使用 <code>is</code> 来进行类型转换,注意: <code>is</code> 操作符永远不会抛出异常 只会返回<code>true</code> 和 <code>false</code></p><p>如果对象引用是 <code>null</code> ,这样总是会返回<code>false</code>,因为没有可以检查类型的对象</p><pre class=" language-c#"><code class="language-c#">if(o is Employee)&#123;    Employee e = (Employee) o;&#125;</code></pre><p>可以看出以上的代码检查了两次o的类型,对性能很不好,所以c#专门提供了as操作符,目的就是简化这种代码</p><p><code>as</code>可以核实是否兼容<code>Employee</code>类型,同时会返回一个<code>Employee</code>的非<code>null</code>引用.当然如果o不能转型,结果就会是<code>null</code>;</p><ol start="4"><li>clr调用一个方法的过程,详见书本108页,由于没有图床,所以没有解析了<br>所以就直接讲下我的理解</li></ol><pre class=" language-c#"><code class="language-c#">void M1()&#123;    string name = "Joe";    M2(name);    ...    return;&#125;void M2(string s)&#123;    int length = s.Length;    int tally;    ...    return;&#125;</code></pre><ul><li>首先执行m1方法,读到name变量 会把name压栈</li><li>然后执行M2,这时候会创建一个m2的局部变量块,把s压栈</li><li>然后把m2的return压栈,使得被调用的方法结束后可以返回值该位置</li><li>然后m2方法也会为length和tally在栈中创建位置,最后调用完回到上面的返回位置</li></ul><p>如果使用了引用类型比如说自定义的一个class,这时候就不仅在栈开辟空间了,还会在托管堆里面开辟空间</p><p>假设有两个复杂类型 <code>Manager</code> 和 <code>Employee</code>,<br>首先clr会为方法中的所有局部变量都初始化为<code>null</code>或者<code>0</code>,如果代码企图访问未显式初始化的局部变量,c#就会报告空引用异常,</p><p>像 <code>Manager</code> 这种复杂类型,会在托管堆中创建一个实例,里面会有几个东西</p><ol><li>类型对象指针</li><li>同步块索引</li><li>静态字段</li><li>自定义的字段</li><li>方法表</li></ol><blockquote><p>类型对象指针：指向类型对象存储的地址，假如有一个类型Person,它在堆中有一块区域存储它内部的字段和成员以及两个额外成员（类型对象指针、 同步块索引 ），类型对象的类型对象指针指向的是System.Type的地址。<br>因为Person类型在内存中相对于System.Type也是作为一个对象存在的，System.Type类型也是一个类型对象，它的类型对象指针指向本身；<br>实例化一个Person对象，Person p = new Person(); p对象在内存堆中也分配一块区域存储它内部的字段和成员以及两个额外成员（类型对象指针、 同步块索引 ），p的类型对象指针指向Person类型在堆中的地址。<br>同步块索引：先说一下同步块，.NET团队在设计基本框架时充分考虑了线程同步的问题，其结果就是.NET为每一个堆内对象都提供了支持线程同步的功能，这就是同步机制的雏形【参考：<a href="http://genwoxuedotnet.blog.51cto.com/1852748/504107">http://genwoxuedotnet.blog.51cto.com/1852748/504107</a>】<br>但是对每个堆内对象都分配同步块有一个较大的弊端，就是这样增大了内存的消耗。在一般的系统中，需要同步机制支持的对象可能只占少数，这样对于大多数对象来说，一个同步块的内存消耗就完全被浪费了。鉴于这一点，.NET框架采用了一种折中的办法，就是实际只为每个堆内对象分配一个同步索引，该索引中只保存一个表明数组内索引的整数。.NET在加载时会新建一个同步块数组，当某个对象需要被同步时，.NET会为其分配一个同步块，并且把该同步块在同步块数组中的索引加入该对象的同步块索引中。<br>同步块机制包含如下的几点：<br>· 在.NET被加载时初始化同步块数组。<br>· 每一个被分配在堆上的对象都会包含两个额外的字段，其中一个存储类型指针，而另外一个就是同步块索引，初始时被赋值为-1。<br>· 当一个线程试图使用该对象进入同步时，会检查该对象的同步索引。如果索引为负数，则会在同步块数组中寻找或者新建一个同步块，并且把同步块的索引值写入该对象的同步索引中。如果该对象的同步索引不为负值，则找到该对象的同步块并且检查是否有其他线程在使用该同步块，如果有则进入等待状态，如果没有则申明使用该同步块。<br>以上引用来源于 <a href="https://www.cnblogs.com/dawenyang/p/7520263.html">https://www.cnblogs.com/dawenyang/p/7520263.html</a></p></blockquote><p>clr调用一个非虚的实例方法的是否, jit会找到与”发出调用的那个变量(e)的类型(Employee)”对应的类型对象.但是如果Employee没找到,那么jit就会回溯层次结构,一直回溯到Object,并在沿途的每个类型中查找该方法.之所以能这样回溯,是<strong>因为每个类型对象都有个字段引用了它的基类型</strong></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/06/25/hello-world/"/>
      <url>2021/06/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dotnetcore控制台使用依赖注入和logger和configuration</title>
      <link href="2020/10/13/study-notes-dotnetcore-2020-10-13-dotnetcore-kong-zhi-tai-shi-yong-yi-lai-zhu-ru-he-logger-he-configuration/"/>
      <url>2020/10/13/study-notes-dotnetcore-2020-10-13-dotnetcore-kong-zhi-tai-shi-yong-yi-lai-zhu-ru-he-logger-he-configuration/</url>
      
        <content type="html"><![CDATA[<h1 id="dotnet-core-3-1在控制台使用依赖注入，logger和configuration"><a href="#dotnet-core-3-1在控制台使用依赖注入，logger和configuration" class="headerlink" title="dotnet core 3.1在控制台使用依赖注入，logger和configuration"></a>dotnet core 3.1在控制台使用依赖注入，logger和configuration</h1><ol><li><p>添加<code>IServiceCollection</code></p><pre class=" language-c#"><code class="language-c#">//会用上的命名空间using Microsoft.Extensions.DependencyInjection;IServiceCollection services = new ServiceCollection();// 然后就可以像在asp.net core 里面的 注入了</code></pre></li></ol><ol start="2"><li><p>创建<code>servicesProvider</code>实列</p><pre class=" language-c#"><code class="language-c#">//创建服务 var servicesProvider = services.BuildServiceProvider();</code></pre></li></ol><ol start="3"><li>在控制台中获取注入</li></ol><pre class=" language-c#"><code class="language-c#">var airServices = servicesProvider.GetService<AirWalkServices>();</code></pre><ol start="4"><li>在其他文件中注入和asp.net core同理，在构造函数中注入即可</li><li>使用log</li></ol><pre class=" language-c#"><code class="language-c#">//启用日志,记得是在创建servicesProvider实列之前services.AddLogging(builder => builder.AddConsole());//使用loggervar logger = servicesProvider.GetService<ILoggerFactory>().CreateLogger<Program>();logger.LogInformation("start app");//其他文件中使用直接注入即可</code></pre><blockquote><p>注意，这里的 <code>builder.AddConsole()</code>可能垃圾VS没有提示，需要安装这个包</p><p><code>Microsoft.Extensions.Logging.Console</code></p></blockquote><p>如果需要使用其它log，把log记录到日志，数据库，建议使用第三方log</p><blockquote><p>例子：<a href="https://mp.weixin.qq.com/s/rg3JbwPY7zNx6UPKEBIIuA">https://mp.weixin.qq.com/s/rg3JbwPY7zNx6UPKEBIIuA</a></p></blockquote><ol start="6"><li>使用config</li></ol><p>需要引用这个几个包，VS大概率又又又没提示</p><blockquote><pre><code>Microsoft.Extensions.Configuration.FileExtensionsMicrosoft.Extensions.Configuration.Json</code></pre></blockquote><pre class=" language-c#"><code class="language-c#">IConfiguration configuration = new ConfigurationBuilder().SetBasePath(Directory.GetCurrentDirectory())                    .AddJsonFile("appsettings.json")                    .Build(); services.AddSingleton(configuration);//Directory.GetCurrentDirectory()这个方法根据微软文档的说法，如果是windows服务的程序，获取的是c盘system文件夹，暂时找不到链接了</code></pre><p>使用同直接注入就行</p><pre class=" language-c#"><code class="language-c#">private readonly IConfiguration _configuration;public Class1(IConfiguration configuration)&#123;    _configuration = configuration;&#125;</code></pre><p>同理也可以使用其他的json文件</p><pre class=" language-c#"><code class="language-c#">IConfiguration tempConfig = new ConfigurationBuilder().SetBasePath(Directory.GetCurrentDirectory())                    .AddJsonFile("你的json文件")                    .Build();//然后我把它注入到了这个TemplateDto类services.Configure<TemplateDto>(tempConfig);</code></pre><p>调用</p><pre class=" language-c#"><code class="language-c#">private readonly IOptions<TemplateDto> _options;public Class1(IOptions<TemplateDto> options)&#123;    _options = options;&#125;</code></pre><p>以上，完成</p><p>2020-10-9 10:48 第一版</p>]]></content>
      
      
      <categories>
          
          <category> dotnetcore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dotnetcore </tag>
            
            <tag> .netcore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c#对文件进行压缩</title>
      <link href="2020/10/13/study-notes-c-2020-10-13-c-dui-wen-jian-jin-xing-ya-suo/"/>
      <url>2020/10/13/study-notes-c-2020-10-13-c-dui-wen-jian-jin-xing-ya-suo/</url>
      
        <content type="html"><![CDATA[<h1 id="c-压缩文件成zip"><a href="#c-压缩文件成zip" class="headerlink" title="c# 压缩文件成zip"></a>c# 压缩文件成zip</h1><blockquote><p>本篇资料引用  <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.compression.zipfile?view=netcore-3.1">微软文档</a></p><blockquote><p>真的建议大家过看看微软的官方文档，啥都有</p></blockquote></blockquote><p>c# 内置了几个处理压缩的类，详细见上面的链接，都是在<code>system.IO.Compression</code>这个命名空间下</p><p><code>zipfile</code>使用心得，都是从目录入手，对目录文件进行压缩，也就是说要先有文件，才能压缩，应该有对<code>byte[]</code>和<code>stream</code>直接进行压缩的类，但是我没有找到</p><p>官方列子</p><pre class=" language-c#"><code class="language-c#">using System;using System.IO.Compression;class Program&#123;    static void Main(string[] args)    &#123;        string startPath = @".\start";        string zipPath = @".\result.zip";        string extractPath = @".\extract";        ZipFile.CreateFromDirectory(startPath, zipPath);        ZipFile.ExtractToDirectory(zipPath, extractPath);    &#125;&#125;</code></pre><p>很明显的用法，<code>CreateFromDirectory</code> 方法就是从这个<code>startPath</code>目录创建压缩文件，<code>zipPath</code>就是要输出的目录，<em>注意：这两个最好在不同的目录，否则会出现文件被占用的错误</em></p><p>ExtractToDirectory 同理相反着用</p><p>附上我当时写的，因为本意是将byte[]直接压缩的，但是，出来的效果就是把.xlsx的后缀名换了个名字，无奈之下只能这样先保存了在压缩，再让浏览器下载</p><pre class=" language-c#"><code class="language-c#">        /// <summary>        /// 将byte压缩        /// </summary>        /// <param name="fileName">文件保存的名字</param>        /// <param name="zipFileNmae">压缩文件的名字</param>        /// <param name="sourceByte">字节</param>        /// <param name="webrootPath">wwwroot目录</param>        /// <returns>压缩后的文件路劲</returns>        public static string CompressToZIP(string fileName,string zipFileNmae,byte[] sourceByte,string webrootPath)        &#123;            var basePath = webrootPath;            var tempFolder = "temp";            var xlsxTempFolder = "Excel";            var zipTempFolder = "Zip";            var tempXlsxPath = Path.Combine(basePath, tempFolder, xlsxTempFolder);            var tempZipPath = Path.Combine(basePath, tempFolder, zipTempFolder);            if (!Directory.Exists(tempXlsxPath))            &#123;                Directory.CreateDirectory(tempXlsxPath);            &#125;            if (!Directory.Exists(tempZipPath))            &#123;                Directory.CreateDirectory(tempZipPath);            &#125;            DeleteDirAllFile(tempXlsxPath);            DeleteDirAllFile(tempZipPath);            var filePath = Path.Combine(tempXlsxPath, fileName);            var zipFilePath = Path.Combine(tempZipPath, zipFileNmae);            SaveTempExcel(sourceByte, filePath);            ZipFile.CreateFromDirectory(tempXlsxPath, zipFilePath, System.IO.Compression.CompressionLevel.Optimal, false);            return zipFilePath;        &#125;        /// <summary>        /// 将byte保存为文件        /// </summary>        /// <param name="buff"></param>        /// <param name="savepath"></param>        public static void SaveTempExcel(byte[] buff, string savepath)        &#123;            if (System.IO.File.Exists(savepath))            &#123;                System.IO.File.Delete(savepath);            &#125;            FileStream fs = new FileStream(savepath, FileMode.Create);            BinaryWriter bw = new BinaryWriter(fs);            bw.Write(buff, 0, buff.Length);            bw.Close();            fs.Close();        &#125;        /// <summary>        /// 将文件转换为byte数组        /// </summary>        /// <param name="path">文件地址</param>        /// <returns>转换后的byte数组</returns>        public static byte[] File2Bytes(string path)        &#123;            if (!System.IO.File.Exists(path))            &#123;                return new byte[0];            &#125;            FileInfo fi = new FileInfo(path);            byte[] buff = new byte[fi.Length];            FileStream fs = fi.OpenRead();            fs.Read(buff, 0, Convert.ToInt32(fs.Length));            fs.Close();            return buff;        &#125;        /// <summary>        /// 删除文件夹下的所有文件        /// </summary>        /// <param name="dirRoot">删除path</param>        public static void DeleteDirAllFile(string dirRoot)        &#123;            DirectoryInfo aDirectoryInfo = new DirectoryInfo(dirRoot);            FileInfo[] files = aDirectoryInfo.GetFiles("*.*", SearchOption.AllDirectories);            foreach (FileInfo f in files)            &#123;                File.Delete(f.FullName);            &#125;        &#125;</code></pre><blockquote><p>理论上应该还是直接返回流下载，返回压缩的流最好，因为我在搜索过程中，发现有些人的生产环境没有创建文件的权限的</p></blockquote><p>文章很简单，能力有限，请有更好的想法的，欢迎留言</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
