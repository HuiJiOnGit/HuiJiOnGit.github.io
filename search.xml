<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CLR via 第4章 类型基础</title>
      <link href="2021/06/25/clr-via-yue-du-wen-da-1/"/>
      <url>2021/06/25/clr-via-yue-du-wen-da-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>by the way 此文章主要用来记录我阅读过程中记下应该写下来,或者说应该要牢记的知识点</p></blockquote><hr><h1 id="第4章-类型基础"><a href="#第4章-类型基础" class="headerlink" title="第4章: 类型基础"></a>第4章: 类型基础</h1><ol><li>所有类型都是从 <code>System.Object</code> 派生</li></ol><p>新建一个类型,就算不写继承于谁,默认都是继承了 <code>Object</code><br><code>Object</code> 类中包含了 <code>Equals</code> <code>GetHashCode</code> <code>ToString</code> <code>GetType</code> 等几个方法,所以你才能在一般的类中使用这些方法.</p><ol start="2"><li>类型转换</li></ol><blockquote><p>CLR最重要的特性之一就是类型安全, 在运行时,clr总能知道这个对象的类型是什么,调用 GetType 方法就知道,而且GetType不是虚方法,所以一个类型不可能伪装成为另一个类型</p></blockquote><blockquote><p>c#不要求任何特殊语法即可将对象转换为它的任意基类型,因为向基转换被认为是一种安全的隐式转换, 但是相反的,由基类型转向派生类型时c#要求开发人员要进行显示转换,因为这种转换有可能会失败</p></blockquote><ol start="3"><li>使用<code>is</code> 和 <code>as</code> 来转换类型</li></ol><p>可以使用 <code>is</code> 来进行类型转换,注意: <code>is</code> 操作符永远不会抛出异常 只会返回<code>true</code> 和 <code>false</code></p><p>如果对象引用是 <code>null</code> ,这样总是会返回<code>false</code>,因为没有可以检查类型的对象</p><pre class=" language-c#"><code class="language-c#">if(o is Employee)&#123;    Employee e = (Employee) o;&#125;</code></pre><p>可以看出以上的代码检查了两次o的类型,对性能很不好,所以c#专门提供了as操作符,目的就是简化这种代码</p><p><code>as</code>可以核实是否兼容<code>Employee</code>类型,同时会返回一个<code>Employee</code>的非<code>null</code>引用.当然如果o不能转型,结果就会是<code>null</code>;</p><ol start="4"><li>clr调用一个方法的过程,详见书本108页,由于没有图床,所以没有解析了<br>所以就直接讲下我的理解</li></ol><pre class=" language-c#"><code class="language-c#">void M1()&#123;    string name = "Joe";    M2(name);    ...    return;&#125;void M2(string s)&#123;    int length = s.Length;    int tally;    ...    return;&#125;</code></pre><ul><li>首先执行m1方法,读到name变量 会把name压栈</li><li>然后执行M2,这时候会创建一个m2的局部变量块,把s压栈</li><li>然后把m2的return压栈,使得被调用的方法结束后可以返回值该位置</li><li>然后m2方法也会为length和tally在栈中创建位置,最后调用完回到上面的返回位置</li></ul><p>如果使用了引用类型比如说自定义的一个class,这时候就不仅在栈开辟空间了,还会在托管堆里面开辟空间</p><p>假设有两个复杂类型 <code>Manager</code> 和 <code>Employee</code>,<br>首先clr会为方法中的所有局部变量都初始化为<code>null</code>或者<code>0</code>,如果代码企图访问未显式初始化的局部变量,c#就会报告空引用异常,</p><p>像 <code>Manager</code> 这种复杂类型,会在托管堆中创建一个实例,里面会有几个东西</p><ol><li>类型对象指针</li><li>同步块索引</li><li>静态字段</li><li>自定义的字段</li><li>方法表</li></ol><blockquote><p>类型对象指针：指向类型对象存储的地址，假如有一个类型Person,它在堆中有一块区域存储它内部的字段和成员以及两个额外成员（类型对象指针、 同步块索引 ），类型对象的类型对象指针指向的是System.Type的地址。<br>因为Person类型在内存中相对于System.Type也是作为一个对象存在的，System.Type类型也是一个类型对象，它的类型对象指针指向本身；<br>实例化一个Person对象，Person p = new Person(); p对象在内存堆中也分配一块区域存储它内部的字段和成员以及两个额外成员（类型对象指针、 同步块索引 ），p的类型对象指针指向Person类型在堆中的地址。<br>同步块索引：先说一下同步块，.NET团队在设计基本框架时充分考虑了线程同步的问题，其结果就是.NET为每一个堆内对象都提供了支持线程同步的功能，这就是同步机制的雏形【参考：<a href="http://genwoxuedotnet.blog.51cto.com/1852748/504107">http://genwoxuedotnet.blog.51cto.com/1852748/504107</a>】<br>但是对每个堆内对象都分配同步块有一个较大的弊端，就是这样增大了内存的消耗。在一般的系统中，需要同步机制支持的对象可能只占少数，这样对于大多数对象来说，一个同步块的内存消耗就完全被浪费了。鉴于这一点，.NET框架采用了一种折中的办法，就是实际只为每个堆内对象分配一个同步索引，该索引中只保存一个表明数组内索引的整数。.NET在加载时会新建一个同步块数组，当某个对象需要被同步时，.NET会为其分配一个同步块，并且把该同步块在同步块数组中的索引加入该对象的同步块索引中。<br>同步块机制包含如下的几点：<br>· 在.NET被加载时初始化同步块数组。<br>· 每一个被分配在堆上的对象都会包含两个额外的字段，其中一个存储类型指针，而另外一个就是同步块索引，初始时被赋值为-1。<br>· 当一个线程试图使用该对象进入同步时，会检查该对象的同步索引。如果索引为负数，则会在同步块数组中寻找或者新建一个同步块，并且把同步块的索引值写入该对象的同步索引中。如果该对象的同步索引不为负值，则找到该对象的同步块并且检查是否有其他线程在使用该同步块，如果有则进入等待状态，如果没有则申明使用该同步块。<br>以上引用来源于 <a href="https://www.cnblogs.com/dawenyang/p/7520263.html">https://www.cnblogs.com/dawenyang/p/7520263.html</a></p></blockquote><p>clr调用一个非虚的实例方法的是否, jit会找到与”发出调用的那个变量(e)的类型(Employee)”对应的类型对象.但是如果Employee没找到,那么jit就会回溯层次结构,一直回溯到Object,并在沿途的每个类型中查找该方法.之所以能这样回溯,是<strong>因为每个类型对象都有个字段引用了它的基类型</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/06/25/hello-world/"/>
      <url>2021/06/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dotnetcore控制台使用依赖注入和logger和configuration</title>
      <link href="2020/10/13/dotnetcore-kong-zhi-tai-shi-yong-yi-lai-zhu-ru-he-logger-he-configuration/"/>
      <url>2020/10/13/dotnetcore-kong-zhi-tai-shi-yong-yi-lai-zhu-ru-he-logger-he-configuration/</url>
      
        <content type="html"><![CDATA[<h1 id="dotnet-core-3-1在控制台使用依赖注入，logger和configuration"><a href="#dotnet-core-3-1在控制台使用依赖注入，logger和configuration" class="headerlink" title="dotnet core 3.1在控制台使用依赖注入，logger和configuration"></a>dotnet core 3.1在控制台使用依赖注入，logger和configuration</h1><ol><li><p>添加<code>IServiceCollection</code></p><pre class=" language-c#"><code class="language-c#">//会用上的命名空间using Microsoft.Extensions.DependencyInjection;IServiceCollection services = new ServiceCollection();// 然后就可以像在asp.net core 里面的 注入了</code></pre></li></ol><ol start="2"><li><p>创建<code>servicesProvider</code>实列</p><pre class=" language-c#"><code class="language-c#">//创建服务 var servicesProvider = services.BuildServiceProvider();</code></pre></li></ol><ol start="3"><li>在控制台中获取注入</li></ol><pre class=" language-c#"><code class="language-c#">var airServices = servicesProvider.GetService<AirWalkServices>();</code></pre><ol start="4"><li>在其他文件中注入和asp.net core同理，在构造函数中注入即可</li><li>使用log</li></ol><pre class=" language-c#"><code class="language-c#">//启用日志,记得是在创建servicesProvider实列之前services.AddLogging(builder => builder.AddConsole());//使用loggervar logger = servicesProvider.GetService<ILoggerFactory>().CreateLogger<Program>();logger.LogInformation("start app");//其他文件中使用直接注入即可</code></pre><blockquote><p>注意，这里的 <code>builder.AddConsole()</code>可能垃圾VS没有提示，需要安装这个包</p><p><code>Microsoft.Extensions.Logging.Console</code></p></blockquote><p>如果需要使用其它log，把log记录到日志，数据库，建议使用第三方log</p><blockquote><p>例子：<a href="https://mp.weixin.qq.com/s/rg3JbwPY7zNx6UPKEBIIuA">https://mp.weixin.qq.com/s/rg3JbwPY7zNx6UPKEBIIuA</a></p></blockquote><ol start="6"><li>使用config</li></ol><p>需要引用这个几个包，VS大概率又又又没提示</p><blockquote><pre><code>Microsoft.Extensions.Configuration.FileExtensionsMicrosoft.Extensions.Configuration.Json</code></pre></blockquote><pre class=" language-c#"><code class="language-c#">IConfiguration configuration = new ConfigurationBuilder().SetBasePath(Directory.GetCurrentDirectory())                    .AddJsonFile("appsettings.json")                    .Build(); services.AddSingleton(configuration);//Directory.GetCurrentDirectory()这个方法根据微软文档的说法，如果是windows服务的程序，获取的是c盘system文件夹，暂时找不到链接了</code></pre><p>使用同直接注入就行</p><pre class=" language-c#"><code class="language-c#">private readonly IConfiguration _configuration;public Class1(IConfiguration configuration)&#123;    _configuration = configuration;&#125;</code></pre><p>同理也可以使用其他的json文件</p><pre class=" language-c#"><code class="language-c#">IConfiguration tempConfig = new ConfigurationBuilder().SetBasePath(Directory.GetCurrentDirectory())                    .AddJsonFile("你的json文件")                    .Build();//然后我把它注入到了这个TemplateDto类services.Configure<TemplateDto>(tempConfig);</code></pre><p>调用</p><pre class=" language-c#"><code class="language-c#">private readonly IOptions<TemplateDto> _options;public Class1(IOptions<TemplateDto> options)&#123;    _options = options;&#125;</code></pre><p>以上，完成</p><p>2020-10-9 10:48 第一版</p>]]></content>
      
      
      <categories>
          
          <category> dotnetcore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dotnetcore .netcore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c#对文件进行压缩</title>
      <link href="2020/10/13/c-dui-wen-jian-jin-xing-ya-suo/"/>
      <url>2020/10/13/c-dui-wen-jian-jin-xing-ya-suo/</url>
      
        <content type="html"><![CDATA[<h1 id="c-压缩文件成zip"><a href="#c-压缩文件成zip" class="headerlink" title="c# 压缩文件成zip"></a>c# 压缩文件成zip</h1><blockquote><p>本篇资料引用  <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.compression.zipfile?view=netcore-3.1">微软文档</a></p><blockquote><p>真的建议大家过看看微软的官方文档，啥都有</p></blockquote></blockquote><p>c# 内置了几个处理压缩的类，详细见上面的链接，都是在<code>system.IO.Compression</code>这个命名空间下</p><p><code>zipfile</code>使用心得，都是从目录入手，对目录文件进行压缩，也就是说要先有文件，才能压缩，应该有对<code>byte[]</code>和<code>stream</code>直接进行压缩的类，但是我没有找到</p><p>官方列子</p><pre class=" language-c#"><code class="language-c#">using System;using System.IO.Compression;class Program&#123;    static void Main(string[] args)    &#123;        string startPath = @".\start";        string zipPath = @".\result.zip";        string extractPath = @".\extract";        ZipFile.CreateFromDirectory(startPath, zipPath);        ZipFile.ExtractToDirectory(zipPath, extractPath);    &#125;&#125;</code></pre><p>很明显的用法，<code>CreateFromDirectory</code> 方法就是从这个<code>startPath</code>目录创建压缩文件，<code>zipPath</code>就是要输出的目录，<em>注意：这两个最好在不同的目录，否则会出现文件被占用的错误</em></p><p>ExtractToDirectory 同理相反着用</p><p>附上我当时写的，因为本意是将byte[]直接压缩的，但是，出来的效果就是把.xlsx的后缀名换了个名字，无奈之下只能这样先保存了在压缩，再让浏览器下载</p><pre class=" language-c#"><code class="language-c#">        /// <summary>        /// 将byte压缩        /// </summary>        /// <param name="fileName">文件保存的名字</param>        /// <param name="zipFileNmae">压缩文件的名字</param>        /// <param name="sourceByte">字节</param>        /// <param name="webrootPath">wwwroot目录</param>        /// <returns>压缩后的文件路劲</returns>        public static string CompressToZIP(string fileName,string zipFileNmae,byte[] sourceByte,string webrootPath)        &#123;            var basePath = webrootPath;            var tempFolder = "temp";            var xlsxTempFolder = "Excel";            var zipTempFolder = "Zip";            var tempXlsxPath = Path.Combine(basePath, tempFolder, xlsxTempFolder);            var tempZipPath = Path.Combine(basePath, tempFolder, zipTempFolder);            if (!Directory.Exists(tempXlsxPath))            &#123;                Directory.CreateDirectory(tempXlsxPath);            &#125;            if (!Directory.Exists(tempZipPath))            &#123;                Directory.CreateDirectory(tempZipPath);            &#125;            DeleteDirAllFile(tempXlsxPath);            DeleteDirAllFile(tempZipPath);            var filePath = Path.Combine(tempXlsxPath, fileName);            var zipFilePath = Path.Combine(tempZipPath, zipFileNmae);            SaveTempExcel(sourceByte, filePath);            ZipFile.CreateFromDirectory(tempXlsxPath, zipFilePath, System.IO.Compression.CompressionLevel.Optimal, false);            return zipFilePath;        &#125;        /// <summary>        /// 将byte保存为文件        /// </summary>        /// <param name="buff"></param>        /// <param name="savepath"></param>        public static void SaveTempExcel(byte[] buff, string savepath)        &#123;            if (System.IO.File.Exists(savepath))            &#123;                System.IO.File.Delete(savepath);            &#125;            FileStream fs = new FileStream(savepath, FileMode.Create);            BinaryWriter bw = new BinaryWriter(fs);            bw.Write(buff, 0, buff.Length);            bw.Close();            fs.Close();        &#125;        /// <summary>        /// 将文件转换为byte数组        /// </summary>        /// <param name="path">文件地址</param>        /// <returns>转换后的byte数组</returns>        public static byte[] File2Bytes(string path)        &#123;            if (!System.IO.File.Exists(path))            &#123;                return new byte[0];            &#125;            FileInfo fi = new FileInfo(path);            byte[] buff = new byte[fi.Length];            FileStream fs = fi.OpenRead();            fs.Read(buff, 0, Convert.ToInt32(fs.Length));            fs.Close();            return buff;        &#125;        /// <summary>        /// 删除文件夹下的所有文件        /// </summary>        /// <param name="dirRoot">删除path</param>        public static void DeleteDirAllFile(string dirRoot)        &#123;            DirectoryInfo aDirectoryInfo = new DirectoryInfo(dirRoot);            FileInfo[] files = aDirectoryInfo.GetFiles("*.*", SearchOption.AllDirectories);            foreach (FileInfo f in files)            &#123;                File.Delete(f.FullName);            &#125;        &#125;</code></pre><blockquote><p>理论上应该还是直接返回流下载，返回压缩的流最好，因为我在搜索过程中，发现有些人的生产环境没有创建文件的权限的</p></blockquote><p>文章很简单，能力有限，请有更好的想法的，欢迎留言</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
